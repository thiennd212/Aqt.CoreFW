# Kế hoạch chi tiết: Tầng EntityFrameworkCore (`Aqt.CoreFW.EntityFrameworkCore`) - Quản lý Thành phần thủ tục (ProcedureComponent)

Phần này mô tả các thành phần cần tạo hoặc cập nhật trong tầng `Aqt.CoreFW.EntityFrameworkCore` cho module Quản lý Thành phần thủ tục (ProcedureComponent).

## 1. DbContext

-   **Vị trí:** Cập nhật file `src/Aqt.CoreFW.EntityFrameworkCore/EntityFrameworkCore/CoreFWDbContext.cs`
-   **Nội dung cần thêm:**
    ```csharp
    using Aqt.CoreFW.Domain.Components.Entities; // Thêm using cho Component Entities
    using Microsoft.EntityFrameworkCore;
    using System.Reflection;
    // ... other usings ...

    public class CoreFWDbContext : AbpDbContext<CoreFWDbContext>, /* ... các interface khác ... */
    {
        // ... các DbSet khác (Procedures, DataGroup, etc.) ...
        public DbSet<ProcedureComponent> ProcedureComponents { get; set; } // Thêm DbSet cho Component
        public DbSet<ProcedureComponentLink> ProcedureComponentLinks { get; set; } // Thêm DbSet cho bảng liên kết


        public CoreFWDbContext(DbContextOptions<CoreFWDbContext> options)
            : base(options)
        {
        }

        protected override void OnModelCreating(ModelBuilder builder)
        {
            base.OnModelCreating(builder);

            // Cấu hình các module khác của ABP...
            // ...

            // Áp dụng tất cả cấu hình entity trong assembly này
            builder.ApplyConfigurationsFromAssembly(Assembly.GetExecutingAssembly());
        }
    }
    ```

## 2. Entity Configuration (`ProcedureComponentConfiguration.cs`)

-   **Vị trí:** Tạo thư mục `src/Aqt.CoreFW.EntityFrameworkCore/EntityTypeConfigurations/Components` (Tạo thư mục nếu chưa có)
-   **Tệp:** Tạo file `ProcedureComponentConfiguration.cs`
-   **Nội dung:**
    ```csharp
    using Aqt.CoreFW.Components; // Namespace chứa ComponentConsts và Enums
    using Aqt.CoreFW.Domain.Components.Entities; // Component Entity
    using Aqt.CoreFW.Domain.Procedures.Entities; // Procedure Entity (for relationship)
    using Aqt.CoreFW.Domain.Shared; // Namespace chứa CoreFWConsts
    using Microsoft.EntityFrameworkCore;
    using Microsoft.EntityFrameworkCore.Metadata.Builders;
    using Volo.Abp.EntityFrameworkCore.Modeling;

    namespace Aqt.CoreFW.EntityFrameworkCore.EntityTypeConfigurations.Components; // Namespace Configuration

    /// <summary>
    /// Configures the database mapping for the <see cref="ProcedureComponent"/> entity.
    /// </summary>
    public class ProcedureComponentConfiguration : IEntityTypeConfiguration<ProcedureComponent>
    {
        public void Configure(EntityTypeBuilder<ProcedureComponent> builder)
        {
            // Sử dụng DbTablePrefix và DbSchema từ CoreFWConsts
            builder.ToTable(CoreFWConsts.DbTablePrefix + "ProcedureComponents", CoreFWConsts.DbSchema);

            builder.ConfigureByConvention(); // Áp dụng các quy ước chuẩn của ABP

            builder.HasKey(x => x.Id);

            // --- Property Configurations ---
            builder.Property(x => x.Code)
                .IsRequired()
                .HasMaxLength(ComponentConsts.MaxCodeLength)
                .HasColumnName(nameof(ProcedureComponent.Code));

            builder.Property(x => x.Name)
                .IsRequired()
                .HasMaxLength(ComponentConsts.MaxNameLength)
                .HasColumnName(nameof(ProcedureComponent.Name));

            builder.Property(x => x.Status)
                .IsRequired()
                .HasColumnName(nameof(ProcedureComponent.Status))
                .HasConversion<byte>(); // Map enum sang byte

            builder.Property(x => x.Order)
                .IsRequired()
                .HasColumnName(nameof(ProcedureComponent.Order));

            builder.Property(x => x.Description)
                .HasMaxLength(ComponentConsts.MaxDescriptionLength)
                .HasColumnName(nameof(ProcedureComponent.Description));

            builder.Property(x => x.Type)
                .IsRequired()
                .HasColumnName(nameof(ProcedureComponent.Type))
                .HasConversion<byte>(); // Map enum sang byte

            // Cấu hình cho FormDefinition - có thể cần kiểu dữ liệu lớn
            builder.Property(x => x.FormDefinition)
                .HasColumnName(nameof(ProcedureComponent.FormDefinition))
                .IsRequired(false); // Nullable
                // .HasColumnType("nvarchar(max)"); // Uncomment nếu cần định nghĩa kiểu dữ liệu cụ thể cho SQL Server
                // .HasColumnType("text"); // Uncomment nếu cần định nghĩa kiểu dữ liệu cụ thể cho PostgreSQL/MySQL

            builder.Property(x => x.TempPath)
                .HasMaxLength(ComponentConsts.MaxTempPathLength)
                .HasColumnName(nameof(ProcedureComponent.TempPath))
                .IsRequired(false); // Nullable

            // --- Relationships ---

            // Many-to-Many relationship with Procedure through ProcedureComponentLink
            builder.HasMany(c => c.ProcedureLinks) // Component has many Links
                   .WithOne() // Each Link relates to one Component (No navigation property back needed here)
                   .HasForeignKey(l => l.ProcedureComponentId) // Foreign key in the Link table
                   .IsRequired()
                   .OnDelete(DeleteBehavior.Cascade); // Xóa link nếu Component bị xóa


            // --- Indexes ---

            // Index cho Code (Unique)
            builder.HasIndex(x => x.Code)
                   .IsUnique() // Đảm bảo Code là duy nhất
                   .HasDatabaseName($"IX_{CoreFWConsts.DbTablePrefix}ProcedureComponents_Code");

            builder.HasIndex(x => x.Name)
                   .HasDatabaseName($"IX_{CoreFWConsts.DbTablePrefix}ProcedureComponents_Name");

            builder.HasIndex(x => x.Status)
                   .HasDatabaseName($"IX_{CoreFWConsts.DbTablePrefix}ProcedureComponents_Status");

            builder.HasIndex(x => x.Type)
                   .HasDatabaseName($"IX_{CoreFWConsts.DbTablePrefix}ProcedureComponents_Type");

            // Index kết hợp cho sắp xếp/lọc phổ biến
            builder.HasIndex(x => new { x.Status, x.Type, x.Order, x.Name })
                  .HasDatabaseName($"IX_{CoreFWConsts.DbTablePrefix}ProcedureComponents_Status_Type_Order_Name");
        }
    }
    ```

## 2.1. Joining Entity Configuration (`ProcedureComponentLinkConfiguration.cs`)

-   **Vị trí:** `src/Aqt.CoreFW.EntityFrameworkCore/EntityTypeConfigurations/Components/`
-   **Tệp:** Tạo file `ProcedureComponentLinkConfiguration.cs`
-   **Nội dung:**
    ```csharp
    using Aqt.CoreFW.Domain.Components.Entities; // ProcedureComponentLink Entity
    using Aqt.CoreFW.Domain.Shared; // CoreFWConsts
    using Microsoft.EntityFrameworkCore;
    using Microsoft.EntityFrameworkCore.Metadata.Builders;
    using Volo.Abp.EntityFrameworkCore.Modeling; // For ConfigureByConvention

    namespace Aqt.CoreFW.EntityFrameworkCore.EntityTypeConfigurations.Components;

    /// <summary>
    /// Configures the database mapping for the <see cref="ProcedureComponentLink"/> joining entity.
    /// </summary>
    public class ProcedureComponentLinkConfiguration : IEntityTypeConfiguration<ProcedureComponentLink>
    {
        public void Configure(EntityTypeBuilder<ProcedureComponentLink> builder)
        {
            // Table Name and Schema
            builder.ToTable(CoreFWConsts.DbTablePrefix + "ProcedureComponentLinks", CoreFWConsts.DbSchema);

            builder.ConfigureByConvention(); // Apply standard conventions if any

            // Define Composite Primary Key
            builder.HasKey(l => new { l.ProcedureId, l.ProcedureComponentId });

            // Foreign Key to Procedure (Configure relationship from Procedure side if needed)
            // EF Core can often infer this, but explicit configuration is clearer.
            // builder.HasOne<Procedure>() // Reference Procedure entity (need using statement)
            //        .WithMany() // Procedure may have many links, but no direct navigation prop defined here
            //        .HasForeignKey(l => l.ProcedureId)
            //        .IsRequired()
            //        .OnDelete(DeleteBehavior.Cascade); // Define delete behavior if Procedure is deleted

            // Foreign Key to ProcedureComponent (Already configured in ProcedureComponentConfiguration via HasMany)
            // builder.HasOne<ProcedureComponent>()
            //        .WithMany(c => c.ProcedureLinks) // Navigation property back to collection
            //        .HasForeignKey(l => l.ProcedureComponentId)
            //        .IsRequired()
            //        .OnDelete(DeleteBehavior.Cascade);

            // Indexes on Foreign Keys for performance
            builder.HasIndex(l => l.ProcedureId)
                   .HasDatabaseName($"IX_{CoreFWConsts.DbTablePrefix}ProcedureComponentLinks_ProcedureId");

            builder.HasIndex(l => l.ProcedureComponentId)
                  .HasDatabaseName($"IX_{CoreFWConsts.DbTablePrefix}ProcedureComponentLinks_ProcedureComponentId");
        }
    }
    ```
    *Lưu ý:* Cấu hình quan hệ `HasOne<Procedure>().WithMany()` ở đây là tùy chọn nếu đã cấu hình từ `ProcedureComponent` hoặc nếu không cần navigation property từ `Procedure` tới `Links`. EF Core thường tự suy luận được.

## 3. Repository Implementation (`ProcedureComponentRepository.cs`)

-   **Vị trí:** Tạo thư mục `src/Aqt.CoreFW.EntityFrameworkCore/Repositories/Components` (Tạo thư mục nếu chưa có)
-   **Tệp:** Tạo file `ProcedureComponentRepository.cs` bên trong thư mục trên
-   **Nội dung:**
    ```csharp
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Linq.Dynamic.Core;
    using System.Threading;
    using System.Threading.Tasks;
    using Aqt.CoreFW.Components; // Enum namespace
    using Aqt.CoreFW.Domain.Components; // IProcedureComponentRepository
    using Aqt.CoreFW.Domain.Components.Entities; // Entities namespace
    using Aqt.CoreFW.EntityFrameworkCore; // CoreFWDbContext, EfCoreRepository
    using JetBrains.Annotations;
    using Microsoft.EntityFrameworkCore;
    using Volo.Abp.Domain.Repositories.EntityFrameworkCore;
    using Volo.Abp.EntityFrameworkCore;

    namespace Aqt.CoreFW.EntityFrameworkCore.Repositories.Components;

    public class ProcedureComponentRepository :
        EfCoreRepository<CoreFWDbContext, ProcedureComponent, Guid>,
        IProcedureComponentRepository
    {
        public ProcedureComponentRepository(IDbContextProvider<CoreFWDbContext> dbContextProvider)
            : base(dbContextProvider)
        {
        }

        // Helper to optionally include details (ProcedureLinks)
        protected virtual async Task<IQueryable<ProcedureComponent>> GetQueryableAsync(bool includeDetails = false)
        {
            var query = (await GetDbSetAsync()).AsQueryable();
            if (includeDetails)
            {
                query = query.Include(c => c.ProcedureLinks);
            }
            return query;
        }

        public async Task<ProcedureComponent?> FindByCodeAsync(
            [NotNull] string code,
            bool includeDetails = true, // Default to true for finding single item
            CancellationToken cancellationToken = default)
        {
            var query = await GetQueryableAsync(includeDetails);
            return await query.AsNoTracking()
                              .FirstOrDefaultAsync(p => p.Code == code, GetCancellationToken(cancellationToken));
        }

        public async Task<bool> CodeExistsAsync(
            [NotNull] string code,
            Guid? excludeId = null,
            CancellationToken cancellationToken = default)
        {
            var dbSet = await GetDbSetAsync();
            var query = dbSet.AsNoTracking().Where(p => p.Code == code);

            if (excludeId.HasValue)
            {
                query = query.Where(p => p.Id != excludeId.Value);
            }

            return await query.AnyAsync(GetCancellationToken(cancellationToken));
        }

        public async Task<List<ProcedureComponent>> GetListAsync(
            string? filterText = null,
            string? code = null,
            string? name = null,
            ComponentStatus? status = null,
            ComponentType? type = null,
            Guid? procedureId = null,
            string? sorting = null,
            int maxResultCount = int.MaxValue,
            int skipCount = 0,
            bool includeDetails = false, // Default to false for list
            CancellationToken cancellationToken = default)
        {
            var query = await GetListQueryInternalAsync(filterText, code, name, status, type, procedureId, includeDetails);

            query = query.OrderBy(sorting.IsNullOrWhiteSpace() ?
                $"{nameof(ProcedureComponent.Order)} asc, {nameof(ProcedureComponent.Name)} asc" // Default sort
                : sorting);

            return await query.PageBy(skipCount, maxResultCount)
                              .ToListAsync(GetCancellationToken(cancellationToken));
        }

        public async Task<long> GetCountAsync(
            string? filterText = null,
            string? code = null,
            string? name = null,
            ComponentStatus? status = null,
            ComponentType? type = null,
            Guid? procedureId = null,
            CancellationToken cancellationToken = default)
        {
            // Don't include details for count
            var query = await GetListQueryInternalAsync(filterText, code, name, status, type, procedureId, includeDetails: false);
            return await query.LongCountAsync(GetCancellationToken(cancellationToken));
        }

        public async Task<List<Guid>> GetLinkedProcedureIdsAsync(
            Guid componentId,
            CancellationToken cancellationToken = default)
        {
            var dbContext = await GetDbContextAsync();
            return await dbContext.ProcedureComponentLinks
                                  .AsNoTracking()
                                  .Where(l => l.ProcedureComponentId == componentId)
                                  .Select(l => l.ProcedureId)
                                  .Distinct() // Ensure distinct IDs
                                  .ToListAsync(GetCancellationToken(cancellationToken));
        }

         public async Task<List<ProcedureComponentLink>> GetComponentLinksAsync(
             Guid componentId,
             CancellationToken cancellationToken = default)
         {
            var dbContext = await GetDbContextAsync();
             return await dbContext.ProcedureComponentLinks
                                   .AsQueryable() // Keep trackable for potential deletes
                                   .Where(l => l.ProcedureComponentId == componentId)
                                   .ToListAsync(GetCancellationToken(cancellationToken));
         }

        // Implement efficient bulk delete for links
        public async Task DeleteManyComponentLinksAsync(
            [NotNull] List<ProcedureComponentLink> links,
            bool autoSave = false,
            CancellationToken cancellationToken = default)
        {
             Check.NotNull(links, nameof(links));
             if (!links.Any()) return; // Nothing to delete

             var dbContext = await GetDbContextAsync();
             dbContext.ProcedureComponentLinks.RemoveRange(links); // Use EF Core's RemoveRange

             if (autoSave)
             {
                 await dbContext.SaveChangesAsync(GetCancellationToken(cancellationToken));
             }
        }

        // Implement efficient bulk insert for links
        public async Task InsertManyComponentLinksAsync(
            [NotNull] List<ProcedureComponentLink> links,
            bool autoSave = false,
            CancellationToken cancellationToken = default)
        {
             Check.NotNull(links, nameof(links));
             if (!links.Any()) return; // Nothing to insert

            var dbContext = await GetDbContextAsync();
             await dbContext.ProcedureComponentLinks.AddRangeAsync(links, GetCancellationToken(cancellationToken)); // Use EF Core's AddRangeAsync

             if (autoSave)
             {
                 await dbContext.SaveChangesAsync(GetCancellationToken(cancellationToken));
             }
        }


        public async Task<List<ProcedureComponent>> GetLookupAsync(
            ComponentType? type = null,
            bool onlyActive = true,
            string? sorting = "Order ASC, Name ASC",
            CancellationToken cancellationToken = default)
        {
            var query = (await GetDbSetAsync()).AsNoTracking();

            if (onlyActive)
            {
                query = query.Where(p => p.Status == ComponentStatus.Active);
            }
            if(type.HasValue)
            {
                 query = query.Where(p => p.Type == type.Value);
            }

            query = query.OrderBy(sorting.IsNullOrWhiteSpace() ?
                $"{nameof(ProcedureComponent.Order)} asc, {nameof(ProcedureComponent.Name)} asc" // Default sort
                : sorting);

            // Select only necessary fields for lookup? Optional optimization.
            // return await query.Select(p => new ProcedureComponent { Id = p.Id, Name = p.Name, Code = p.Code, Type = p.Type }).ToListAsync(...)
            return await query.ToListAsync(GetCancellationToken(cancellationToken));
        }

        // --- Private Helper Method ---

        private async Task<IQueryable<ProcedureComponent>> GetListQueryInternalAsync(
            string? filterText = null,
            string? code = null,
            string? name = null,
            ComponentStatus? status = null,
            ComponentType? type = null,
            Guid? procedureId = null,
            bool includeDetails = false)
        {
            var dbContext = await GetDbContextAsync();
            var query = await GetQueryableAsync(includeDetails); // Gets base query with optional includes

             query = query.AsNoTracking() // Use AsNoTracking for read-only lists
                // Combined filter for Code or Name
                .WhereIf(!filterText.IsNullOrWhiteSpace(), p =>
                    (p.Code != null && p.Code.Contains(filterText!)) ||
                    (p.Name != null && p.Name.Contains(filterText!)))
                // Specific filters
                .WhereIf(!code.IsNullOrWhiteSpace(), p => p.Code == code)
                .WhereIf(!name.IsNullOrWhiteSpace(), p => p.Name != null && p.Name.Contains(name))
                .WhereIf(status.HasValue, p => p.Status == status!.Value)
                .WhereIf(type.HasValue, p => p.Type == type!.Value);

            // Filter by linked ProcedureId
            if (procedureId.HasValue)
            {
                // Join with the Link table to filter
                query = query.Where(c => dbContext.ProcedureComponentLinks
                                            .Any(l => l.ProcedureComponentId == c.Id && l.ProcedureId == procedureId.Value));

                // Alternative using Navigation Property (requires Include in GetQueryableAsync)
                // query = query.Where(c => c.ProcedureLinks.Any(l => l.ProcedureId == procedureId.Value));
            }

            return query;
        }
    }
    ```

## 4. Cập nhật `CoreFWDbContextModelCreatingExtensions.cs` (Không bắt buộc nếu dùng `ApplyConfigurationsFromAssembly`)

-   **Vị trí:** `src/Aqt.CoreFW.EntityFrameworkCore/EntityFrameworkCore/CoreFWDbContextModelCreatingExtensions.cs`
-   **Hành động:** Nếu **không** sử dụng `builder.ApplyConfigurationsFromAssembly(...)`, bạn cần gọi thủ công các phương thức cấu hình cho `ProcedureComponent` và `ProcedureComponentLink`.
    ```csharp
    public static void ConfigureCoreFW(this ModelBuilder builder)
    {
        Check.NotNull(builder, nameof(builder));

        // ... Cấu hình cho các entity khác (Procedure, etc.)...

        // Cấu hình cho ProcedureComponent và Link
        builder.ApplyConfiguration(new Aqt.CoreFW.EntityFrameworkCore.EntityTypeConfigurations.Components.ProcedureComponentConfiguration());
        builder.ApplyConfiguration(new Aqt.CoreFW.EntityFrameworkCore.EntityTypeConfigurations.Components.ProcedureComponentLinkConfiguration());

        // ... các cấu hình khác ...
    }
    ```
    **Khuyến nghị:** Sử dụng `ApplyConfigurationsFromAssembly`.

## 5. Database Migrations

-   **Hành động:**
    1.  **Thêm Migration:** Mở Package Manager Console (PMC) hoặc terminal, chọn project `Aqt.CoreFW.EntityFrameworkCore` làm project mặc định.
        ```bash
        dotnet ef migrations add Added_ProcedureComponents_Module
        ```
        *(Đặt tên migration mô tả, ví dụ: `Added_ProcedureComponents_And_Links`)*
    2.  **Kiểm tra Migration:** Mở file migration mới (`..._Added_ProcedureComponents_Module.cs`) trong thư mục `Migrations`. Kiểm tra cẩn thận việc tạo bảng `ProcedureComponents` và `ProcedureComponentLinks`, các cột, kiểu dữ liệu, **index unique cho Code**, **khóa chính tổng hợp (composite primary key)** và **khóa ngoại (foreign keys)** cho bảng `ProcedureComponentLinks`.
    3.  **Cập nhật Database:**
        ```bash
        dotnet ef database update
        ```

## 6. Lưu ý

*   **Namespace:** Đảm bảo các namespace là chính xác.
*   **Code Uniqueness:** Cấu hình (`HasIndex(...).IsUnique()`) và Repository (`CodeExistsAsync`) đảm bảo `ProcedureComponent.Code` là duy nhất.
*   **Many-to-Many Configuration:** Cấu hình mối quan hệ Nhiều-Nhiều được thực hiện thông qua `ProcedureComponentConfiguration` (`HasMany(c => c.ProcedureLinks)...`) và `ProcedureComponentLinkConfiguration` (định nghĩa composite key, FKs).
*   **FormDefinition Column Type:** Xem xét lại kiểu dữ liệu cột cho `FormDefinition` (`nvarchar(max)`, `text`, ...) tùy thuộc vào CSDL và độ dài dự kiến.
*   **Repository Implementation:**
    *   Triển khai đầy đủ các phương thức từ `IProcedureComponentRepository`.
    *   Lọc theo `procedureId` trong `GetListQueryInternalAsync` được thực hiện bằng cách join với bảng `ProcedureComponentLinks`.
    *   `DeleteManyComponentLinksAsync` và `InsertManyComponentLinksAsync` sử dụng `RemoveRange` và `AddRangeAsync` của EF Core cho hiệu quả. Các giải pháp tối ưu hơn (bulk extensions) có thể cần thư viện bên ngoài.
    *   Sử dụng `AsNoTracking()` cho các truy vấn chỉ đọc (list, count, find, lookup) để tăng hiệu năng.
*   **Migrations:** Luôn tạo và kiểm tra migration kỹ lưỡng, đặc biệt là composite keys và foreign keys, trước khi cập nhật database.