# Kế hoạch chi tiết: Tầng Application (`Aqt.CoreFW.Application`) - Quản lý Thành phần thủ tục (ProcedureComponent)

Phần này mô tả các thành phần cần tạo hoặc cập nhật trong tầng `Aqt.CoreFW.Application` cho module Quản lý Thành phần thủ tục (ProcedureComponent).

## 1. Mapping Logic

### 1.1. Mapping Action for Excel Export (`ComponentToExcelMappingAction` - Optional)

-   **Mục đích:** Xử lý logic mapping tùy chỉnh khi chuyển đổi từ `ProcedureComponent` (Entity) sang `ProcedureComponentExcelDto`, chủ yếu để địa phương hóa `StatusText` và `TypeText`.
-   **Vị trí:** Tạo thư mục `src/Aqt.CoreFW.Application/Components` (nếu chưa có)
-   **Tệp:** Tạo file `ComponentToExcelMappingAction.cs` (Nếu có chức năng Export Excel)
-   **Nội dung:**
    ```csharp
    using Aqt.CoreFW.Application.Contracts.Components.Dtos; // ProcedureComponentExcelDto
    using Aqt.CoreFW.Domain.Components.Entities; // ProcedureComponent Entity
    using Aqt.CoreFW.Localization; // CoreFWResource for L[]
    using AutoMapper;
    using Microsoft.Extensions.Localization; // Required for IStringLocalizer
    using Volo.Abp.DependencyInjection; // Required for ITransientDependency

    namespace Aqt.CoreFW.Application.Components; // Namespace for Component Application layer

    /// <summary>
    /// AutoMapper mapping action to handle specific logic when mapping
    /// from ProcedureComponent entity to ProcedureComponentExcelDto.
    /// Primarily handles localization of Status and Type enums.
    /// </summary>
    public class ComponentToExcelMappingAction
        : IMappingAction<ProcedureComponent, ProcedureComponentExcelDto>, ITransientDependency
    {
        private readonly IStringLocalizer<CoreFWResource> _localizer;

        public ComponentToExcelMappingAction(IStringLocalizer<CoreFWResource> localizer)
        {
            _localizer = localizer;
        }

        public void Process(ProcedureComponent source, ProcedureComponentExcelDto destination, ResolutionContext context)
        {
            // Localize the Status enum
            destination.StatusText = _localizer[$"Enum:ComponentStatus.{(int)source.Status}"];
            // Localize the Type enum
            destination.TypeText = _localizer[$"Enum:ComponentType.{(int)source.Type}"];
        }
    }
    ```

### 1.2. AutoMapper Profile (`ProcedureComponentApplicationAutoMapperProfile`)

-   **Vị trí:** Tạo file `src/Aqt.CoreFW.Application/Components/ProcedureComponentApplicationAutoMapperProfile.cs`
-   **Nội dung:**
    ```csharp
    using Aqt.CoreFW.Application.Contracts.Components.Dtos; // DTOs for Component
    using Aqt.CoreFW.Application.Contracts.Shared.Lookups; // Lookup DTOs
    using Aqt.CoreFW.Domain.Components.Entities; // Component Entity
    using AutoMapper;
    using System.Linq; // For Select

    namespace Aqt.CoreFW.Application.Components; // Namespace for Component Application layer

    public class ProcedureComponentApplicationAutoMapperProfile : Profile
    {
        public ProcedureComponentApplicationAutoMapperProfile()
        {
            // --- ProcedureComponent Mappings ---

            // Entity to Read DTO
            // Note: Mapping ProcedureLinks requires the entity to be loaded with details.
            // The standard GetListAsync might not load links, GetAsync override will handle it.
            CreateMap<ProcedureComponent, ProcedureComponentDto>()
                 .ForMember(dest => dest.ProcedureIds,
                            opt => opt.MapFrom(src => src.ProcedureLinks.Select(l => l.ProcedureId).ToList()));

            // Read DTO to Create/Update DTO (for prepopulating edit forms)
            CreateMap<ProcedureComponentDto, CreateUpdateProcedureComponentDto>();

            // Entity to Lookup DTO
            CreateMap<ProcedureComponent, ProcedureComponentLookupDto>();

            // Entity to Excel DTO (if Excel Export is implemented)
            CreateMap<ProcedureComponent, ProcedureComponentExcelDto>()
                .ForMember(dest => dest.StatusText, opt => opt.Ignore()) // Handled by MappingAction
                .ForMember(dest => dest.TypeText, opt => opt.Ignore())   // Handled by MappingAction
                .AfterMap<ComponentToExcelMappingAction>(); // Apply action for localized texts

            // IMPORTANT: No direct mapping from CreateUpdateProcedureComponentDto to ProcedureComponent entity.
            // Create/Update operations use DTO data with ProcedureComponentManager to ensure
            // business logic (like Code uniqueness, Type/Content consistency, link updates) is executed correctly.
        }
    }
    ```

## 2. AppService Implementation (`ProcedureComponentAppService`)

-   **Vị trí:** Tạo file `src/Aqt.CoreFW.Application/Components/ProcedureComponentAppService.cs`
-   **Nội dung:**
    ```csharp
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Linq.Dynamic.Core; // Required for dynamic sorting
    using System.Threading.Tasks;
    using Aqt.CoreFW.Application.Contracts.Components; // Contracts namespace
    using Aqt.CoreFW.Application.Contracts.Components.Dtos; // DTOs namespace
    using Aqt.CoreFW.Application.Contracts.Shared.Lookups; // Lookup DTO namespace
    using Aqt.CoreFW.Shared.Services; // IAbpExcelExportHelper namespace (giả định)
    using Aqt.CoreFW.Domain.Components; // Domain Service and Repository Interface namespace
    using Aqt.CoreFW.Domain.Components.Entities; // Entity namespace
    using Aqt.CoreFW.Localization; // Resource namespace
    using Aqt.CoreFW.Permissions; // Permissions namespace
    using Aqt.CoreFW.Components; // Enum namespace from Domain.Shared
    using Microsoft.AspNetCore.Authorization;
    using Microsoft.Extensions.Localization;
    using Volo.Abp;
    using Volo.Abp.Application.Dtos;
    using Volo.Abp.Application.Services;
    using Volo.Abp.Content; // For IRemoteStreamContent
    using Volo.Abp.Domain.Entities; // For EntityNotFoundException
    using Volo.Abp.ObjectMapping; // For ObjectMapper (though base class provides it)

    namespace Aqt.CoreFW.Application.Components; // Application Service namespace

    [Authorize(CoreFWPermissions.Components.Default)] // Default policy for read
    public class ProcedureComponentAppService :
        CrudAppService<
            ProcedureComponent,             // Entity
            ProcedureComponentDto,          // DTO Read
            Guid,                           // Primary Key
            GetProcedureComponentsInput,    // DTO for GetList input
            CreateUpdateProcedureComponentDto>, // DTO for Create/Update input
        IProcedureComponentAppService       // Implement the contract interface
    {
        private readonly IProcedureComponentRepository _componentRepository;
        private readonly ProcedureComponentManager _componentManager;
        private readonly IStringLocalizer<CoreFWResource> _localizer;
        private readonly IAbpExcelExportHelper? _excelExportHelper; // Optional: For Excel export

        // Constructor injection
        public ProcedureComponentAppService(
            IProcedureComponentRepository componentRepository, // Use specific repo
            ProcedureComponentManager componentManager,
            IStringLocalizer<CoreFWResource> localizer,
            IAbpExcelExportHelper? excelExportHelper = null) // Optional injection
            : base(componentRepository) // Pass specific repo to base
        {
            _componentRepository = componentRepository;
            _componentManager = componentManager;
            _localizer = localizer;
            _excelExportHelper = excelExportHelper;

            // Set permission policies from Contracts
            GetPolicyName = CoreFWPermissions.Components.Default;
            GetListPolicyName = CoreFWPermissions.Components.Default;
            CreatePolicyName = CoreFWPermissions.Components.Create;
            UpdatePolicyName = CoreFWPermissions.Components.Update;
            DeletePolicyName = CoreFWPermissions.Components.Delete;
            // Note: ManageProcedureLinks permission check might be needed within UpdateAsync
        }

        // --- Overridden CRUD Methods ---

        [Authorize(CoreFWPermissions.Components.Create)]
        public override async Task<ProcedureComponentDto> CreateAsync(CreateUpdateProcedureComponentDto input)
        {
            // 1. Use Manager to create the core entity (validates code, type, content)
            var entity = await _componentManager.CreateAsync(
                input.Code,
                input.Name,
                input.Order,
                input.Type,
                input.FormDefinition,
                input.TempPath,
                input.Description,
                input.Status
            );

            // 2. Insert the core entity
            await _componentRepository.InsertAsync(entity, autoSave: true); // AutoSave for initial insert

            // 3. Update the links using the manager (requires entity.Id)
            // Ensure ProcedureIds is not null; default is new List<Guid>() in DTO.
            await _componentManager.UpdateProcedureLinksAsync(entity.Id, input.ProcedureIds ?? new List<Guid>());
            // Save changes after link update if not using AutoSave in UpdateProcedureLinksAsync or rely on UoW completion.
            // await UnitOfWorkManager.Current.SaveChangesAsync(); // If needed and autoSave=false in manager

            // 4. Map the final entity (potentially re-fetched with links if needed) to DTO
            // Mapping requires ProcedureLinks to be populated for ProcedureIds in DTO.
            // Fetch again or assume manager/UoW handles it. Let's assume mapping works after UoW completion.
            return ObjectMapper.Map<ProcedureComponent, ProcedureComponentDto>(entity);
        }

        [Authorize(CoreFWPermissions.Components.Update)]
        public override async Task<ProcedureComponentDto> UpdateAsync(Guid id, CreateUpdateProcedureComponentDto input)
        {
            // Optional: Check ManageProcedureLinks permission if ProcedureIds are being modified
            if (input.ProcedureIds != null) // Assuming null means "don't change links" (adjust logic if needed)
            {
                 // This requires the PermissionChecker to be injected
                 // await AuthorizationService.CheckAsync(CoreFWPermissions.Components.ManageProcedureLinks);
            }

            // 1. Get the existing entity
            var entity = await _componentRepository.GetAsync(id);

            // 2. Check immutable Code (optional but good practice)
            if (!string.Equals(entity.Code, input.Code, StringComparison.OrdinalIgnoreCase))
            {
                throw new UserFriendlyException(_localizer["ComponentCodeCannotBeChanged"]); // Define localization key
            }

            // 3. Use Manager to update the core entity properties
            entity = await _componentManager.UpdateAsync(
                entity,
                input.Name,
                input.Order,
                input.Type,
                input.FormDefinition,
                input.TempPath,
                input.Description,
                input.Status
            );

            // 4. Update the entity in the repository
            await _componentRepository.UpdateAsync(entity, autoSave: true); // AutoSave for property updates

            // 5. Update the links using the manager
             // Ensure ProcedureIds is not null; default is new List<Guid>() in DTO.
            await _componentManager.UpdateProcedureLinksAsync(entity.Id, input.ProcedureIds ?? new List<Guid>());
            // Save changes after link update if needed.
            // await UnitOfWorkManager.Current.SaveChangesAsync();

            // 6. Map the final entity to DTO
            return ObjectMapper.Map<ProcedureComponent, ProcedureComponentDto>(entity);
        }

        // Override GetAsync to ensure ProcedureIds are loaded in the DTO
        public override async Task<ProcedureComponentDto> GetAsync(Guid id)
        {
            // 1. Get the entity, ensuring details (links) are included.
            // Assuming the repository's default GetAsync doesn't guarantee link loading,
            // or using FindAsync which might have includeDetails parameter.
            // Option A: Use a specific method if available:
            // var entity = await _componentRepository.GetWithDetailsAsync(id);
            // Option B: Use base GetAsync and then load links separately (less efficient)
            // var dto = await base.GetAsync(id);
            // dto.ProcedureIds = await _componentRepository.GetLinkedProcedureIdsAsync(id);
            // return dto;
            // Option C: Use repository with includeDetails (if FindAsync supports it or configure eager loading)
            // Let's assume base GetAsync or configuration handles eager loading for this example.
            // If not, manual loading like Option B is required.
            var entity = await _componentRepository.GetAsync(id); // Assumes links are loaded
             if (entity == null)
            {
                 throw new EntityNotFoundException(typeof(ProcedureComponent), id);
            }
            // Manually load links if GetAsync doesn't include them by default
            // This requires the repository method to exist.
            var linkedIds = await _componentRepository.GetLinkedProcedureIdsAsync(id);

            var dto = ObjectMapper.Map<ProcedureComponent, ProcedureComponentDto>(entity);
            dto.ProcedureIds = linkedIds; // Populate the IDs

            return dto;
        }


        // Override GetListAsync to use repository filtering including ProcedureId
        public override async Task<PagedResultDto<ProcedureComponentDto>> GetListAsync(GetProcedureComponentsInput input)
        {
            var totalCount = await _componentRepository.GetCountAsync(
                filterText: input.Filter,
                code: null, // Assuming filterText searches Code and Name
                name: null, // Assuming filterText searches Code and Name
                status: input.Status,
                type: input.Type,
                procedureId: input.ProcedureId // Pass ProcedureId filter
            );

            var entities = await _componentRepository.GetListAsync(
                filterText: input.Filter,
                 code: null,
                name: null,
                status: input.Status,
                type: input.Type,
                procedureId: input.ProcedureId, // Pass ProcedureId filter
                sorting: input.Sorting ?? "Order ASC, Name ASC", // Default sort
                maxResultCount: input.MaxResultCount,
                skipCount: input.SkipCount,
                includeDetails: false // Do NOT include details (links) for list view performance
            );

            // Map to DTO. ProcedureIds will likely be empty due to includeDetails=false.
            var dtos = ObjectMapper.Map<List<ProcedureComponent>, List<ProcedureComponentDto>>(entities);

            return new PagedResultDto<ProcedureComponentDto>(totalCount, dtos);
        }

        // --- Custom AppService Methods ---

        [Authorize] // Allow any authenticated user to get lookups
        public async Task<ListResultDto<ProcedureComponentLookupDto>> GetLookupAsync(ComponentType? type = null)
        {
            // Use the specific repository method for lookups
            var components = await _componentRepository.GetLookupAsync(
                type: type,
                onlyActive: true // Typically only want active items for lookup
                // Sorting is handled by the repository method default
            );

            var dtos = ObjectMapper.Map<List<ProcedureComponent>, List<ProcedureComponentLookupDto>>(components);
            return new ListResultDto<ProcedureComponentLookupDto>(dtos);
        }

        // Optional: Implement Excel Export
        [Authorize(CoreFWPermissions.Components.Export)]
        public async Task<IRemoteStreamContent> GetListAsExcelAsync(GetProcedureComponentsInput input)
        {
             if (_excelExportHelper == null)
            {
                 throw new NotImplementedException("Excel export service (IAbpExcelExportHelper) is not registered.");
            }

            // 1. Get filtered list (no pagination for export)
            var entities = await _componentRepository.GetListAsync(
                filterText: input.Filter,
                 code: null,
                name: null,
                status: input.Status,
                type: input.Type,
                procedureId: input.ProcedureId,
                sorting: input.Sorting ?? "Order ASC, Name ASC",
                maxResultCount: int.MaxValue, // Get all matching records
                skipCount: 0,
                includeDetails: false // No details needed for standard Excel export
            );

            // 2. Map to Excel DTOs using AutoMapper (which uses ComponentToExcelMappingAction)
            var excelDtos = ObjectMapper.Map<List<ProcedureComponent>, List<ProcedureComponentExcelDto>>(entities);

            // 3. Use helper to generate Excel file
            // Ensure the helper service name and method match your implementation.
            var fileContent = await _excelExportHelper.ExportToExcelAsync(excelDtos, "ProcedureComponents"); // Sheet name
            return fileContent;
        }
    }
    ```

## 3. Cập nhật `CoreFWApplicationModule.cs`

-   **Vị trí:** `src/Aqt.CoreFW.Application/CoreFWApplicationModule.cs`
-   **Hành động:** Đảm bảo rằng project `Aqt.CoreFW.Application` có tham chiếu đến `Aqt.CoreFW.Application.Contracts`. Cập nhật phương thức `ConfigureServices` để đăng ký AutoMapper profile mới.
-   **Nội dung cần thêm/cập nhật trong `ConfigureServices`:**
    ```csharp
    Configure<AbpAutoMapperOptions>(options =>
    {
        // Add all profiles in this assembly
        // options.AddMaps<CoreFWApplicationModule>(validate: true); // Validate profiles during startup

        // Hoặc thêm từng profile cụ thể nếu không dùng AddMaps
        options.AddProfile<ProcedureComponentApplicationAutoMapperProfile>(validate: true); // Thêm profile của Component
        options.AddProfile<ProcedureApplicationAutoMapperProfile>(validate: true);
        // ... các profile khác ...
    });
    ```

## 4. Lưu ý

*   **Dependency Injection:** `ProcedureComponentAppService` inject `IProcedureComponentRepository`, `ProcedureComponentManager`, `IStringLocalizer`, và (tùy chọn) `IAbpExcelExportHelper`.
*   **Permissions:** Bảo vệ các phương thức bằng các permission đã định nghĩa (`CoreFWPermissions.Components`). Cân nhắc kiểm tra quyền `ManageProcedureLinks` bên trong `UpdateAsync` nếu cần thiết.
*   **Mapping:** Sử dụng AutoMapper. Cần chú ý việc load dữ liệu liên kết (`ProcedureLinks`) khi mapping sang `ProcedureComponentDto`, đặc biệt là trong `GetAsync` (cần load details) và `GetListAsync` (thường không load details để đảm bảo hiệu năng).
*   **Domain Service Usage:** Logic nghiệp vụ phức tạp (tạo, cập nhật core entity, xử lý liên kết) được ủy thác cho `ProcedureComponentManager`.
*   **Repository Usage:** AppService sử dụng `IProcedureComponentRepository` cho các truy vấn và thao tác cơ bản.
*   **Many-to-Many Link Management:** Việc cập nhật liên kết (`ProcedureComponentLink`) được thực hiện bằng cách gọi `_componentManager.UpdateProcedureLinksAsync` trong cả `CreateAsync` và `UpdateAsync` sau khi entity chính đã được lưu.
*   **Error Handling:** Sử dụng `UserFriendlyException`, `EntityNotFoundException`, `NotImplementedException`, hoặc `BusinessException`.
*   **Excel Export:** Là tùy chọn. Cần đảm bảo `IAbpExcelExportHelper` (hoặc helper tương tự) được đăng ký và inject.
*   **Lookup Optimization:** `GetLookupAsync` sử dụng phương thức chuyên biệt từ repository.
*   **Code Immutability:** `UpdateAsync` có logic kiểm tra và ngăn chặn việc thay đổi `Code`.