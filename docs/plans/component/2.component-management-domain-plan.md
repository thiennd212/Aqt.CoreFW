# Kế hoạch chi tiết: Tầng Domain (`Aqt.CoreFW.Domain`) - Quản lý Thành phần thủ tục (ProcedureComponent)

Phần này mô tả các thành phần cần tạo hoặc cập nhật trong tầng `Aqt.CoreFW.Domain` để hỗ trợ chức năng quản lý Thành phần thủ tục (ProcedureComponent). Kế hoạch này dựa trên yêu cầu trong `docs/srs/component-srs.md`, kế hoạch tổng thể `0.component-plan-v1.md` và kế hoạch tầng Domain.Shared `1.component-management-domain-shared-plan.md`.

## 1. Entity (`ProcedureComponent.cs`)

**Nguyên tắc thiết kế Entity (DDD):**

*   **Đóng gói (Encapsulation):** Sử dụng `private set` cho các thuộc tính. `Code` không thay đổi sau khi tạo. `Type`, `FormDefinition` và `TempPath` được quản lý thông qua phương thức `SetTypeAndContent`.
*   **Validation tập trung:** Sử dụng các phương thức `private` hoặc `internal` chứa logic validation (`Check.*`) với hằng số từ `ComponentConsts`.
*   **Trạng thái hợp lệ (Valid State):** Constructor chính (`internal`) nhận tham số bắt buộc, gọi phương thức validation nội bộ để đảm bảo entity hợp lệ khi khởi tạo. Constructor `protected` dùng cho ORM.
*   **Hành vi (Behavior):** Định nghĩa phương thức `public` để thay đổi trạng thái có kiểm soát (ví dụ: `SetName`, `SetOrder`, `SetDescription`, `SetTypeAndContent`, `Activate`, `Deactivate`).
*   **Kế thừa:** Sử dụng `FullAuditedAggregateRoot<Guid>` theo kế hoạch tổng thể, phù hợp cho entity độc lập và quản lý audit/soft delete.
*   **Quan hệ Nhiều-Nhiều:** Quản lý danh sách các liên kết (`ProcedureLinks`) tới Thủ tục hành chính thông qua bảng trung gian `ProcedureComponentLink`. Các phương thức quản lý collection (`ClearProcedureLinks`, `AddProcedureLink`, `RemoveProcedureLink`) là `internal` và được gọi từ Domain Service (`ProcedureComponentManager`).

**Cấu trúc `ProcedureComponent.cs`:**

-   **Vị trí:** `src/Aqt.CoreFW.Domain/Components/Entities/ProcedureComponent.cs` (Tạo thư mục `Components/Entities` nếu chưa có)
-   **Nội dung:**
    ```csharp
    using System;
    using System.Collections.Generic;
    using System.Collections.ObjectModel; // For Collection initialization
    using Aqt.CoreFW.Components; // Namespace chứa Consts và Enum từ Domain.Shared
    using JetBrains.Annotations;
    using Volo.Abp;
    using Volo.Abp.Domain.Entities.Auditing;

    namespace Aqt.CoreFW.Domain.Components.Entities; // Namespace cụ thể cho Entity

    /// <summary>
    /// Represents a component of an administrative procedure (e.g., a form or a file template).
    /// Inherits from FullAuditedAggregateRoot for audit logging and soft delete.
    /// </summary>
    public class ProcedureComponent : FullAuditedAggregateRoot<Guid>
    {
        /// <summary>
        /// Unique code for the component.
        /// Cannot be changed after creation.
        /// </summary>
        [NotNull]
        public virtual string Code { get; private set; }

        /// <summary>
        /// Name of the component.
        /// </summary>
        [NotNull]
        public virtual string Name { get; private set; }

        /// <summary>
        /// Status of the component (Active/Inactive).
        /// </summary>
        public virtual ComponentStatus Status { get; private set; }

        /// <summary>
        /// Display or processing order.
        /// </summary>
        public virtual int Order { get; private set; }

        /// <summary>
        /// Optional description.
        /// </summary>
        [CanBeNull]
        public virtual string? Description { get; private set; }

        /// <summary>
        /// Type of the component (Form or File). Determines whether FormDefinition or TempPath is used.
        /// </summary>
        public virtual ComponentType Type { get; private set; }

        /// <summary>
        /// Definition for the form (e.g., JSON structure). Used when Type is Form.
        /// Stored as string, potentially large.
        /// </summary>
        [CanBeNull]
        public virtual string? FormDefinition { get; private set; }

        /// <summary>
        /// Path to the template file. Used when Type is File.
        /// </summary>
        [CanBeNull]
        public virtual string? TempPath { get; private set; }

        /// <summary>
        /// Navigation property for the many-to-many relationship with Procedures.
        /// Represents the links to Procedures this component is part of.
        /// </summary>
        public virtual ICollection<ProcedureComponentLink> ProcedureLinks { get; protected set; } // Sử dụng tên mới ProcedureComponentLink

        /// <summary>
        /// Protected constructor for ORM frameworks.
        /// </summary>
        protected ProcedureComponent()
        {
            /* For ORM */
            Code = string.Empty; // Initialize with valid default
            Name = string.Empty; // Initialize with valid default
            ProcedureLinks = new Collection<ProcedureComponentLink>(); // Khởi tạo collection với tên mới
        }

        /// <summary>
        /// Creates a new instance of the <see cref="ProcedureComponent"/> class.
        /// Ensures required fields are provided and validates initial state.
        /// Use ProcedureComponentManager to create instances.
        /// </summary>
        /// <param name="id">The unique identifier.</param>
        /// <param name="code">The unique code.</param> // Manager validates uniqueness
        /// <param name="name">The name.</param>
        /// <param name="order">The display order.</param>
        /// <param name="type">The component type (Form/File).</param>
        /// <param name="formDefinition">Form definition (required if type is Form).</param>
        /// <param name="tempPath">Template path (required if type is File).</param>
        /// <param name="description">Optional description.</param>
        /// <param name="status">The status.</param>
        internal ProcedureComponent( // Constructor internal để buộc tạo qua ProcedureComponentManager
            Guid id,
            [NotNull] string code,
            [NotNull] string name,
            int order,
            ComponentType type,
            [CanBeNull] string? formDefinition = null,
            [CanBeNull] string? tempPath = null,
            [CanBeNull] string? description = null,
            ComponentStatus status = ComponentStatus.Active)
            : base(id)
        {
            // Set Code directly, only once, validated by ProcedureComponentManager
            SetCodeInternal(code);

            // Set other basic properties via internal setters for validation
            SetNameInternal(name);
            SetOrderInternal(order);
            SetDescriptionInternal(description);
            Status = status; // Assign enum directly

            // Set Type and related content (FormDefinition or TempPath)
            // This method includes validation based on type.
            SetTypeAndContentInternal(type, formDefinition, tempPath);

            ProcedureLinks = new Collection<ProcedureComponentLink>(); // Khởi tạo collection với tên mới
        }

        // --- Internal setters with validation ---

        private void SetCodeInternal([NotNull] string code)
        {
            Check.NotNullOrWhiteSpace(code, nameof(code), ComponentConsts.MaxCodeLength);
            Code = code;
        }

        private void SetNameInternal([NotNull] string name)
        {
            Check.NotNullOrWhiteSpace(name, nameof(name), ComponentConsts.MaxNameLength);
            Name = name;
        }

         private void SetOrderInternal(int order)
        {
            // Add validation for Order if needed (e.g., non-negative)
            Order = order;
        }

        private void SetDescriptionInternal([CanBeNull] string? description)
        {
            Check.Length(description, nameof(description), ComponentConsts.MaxDescriptionLength);
            Description = description;
        }

        private void SetFormDefinitionInternal([CanBeNull] string? formDefinition)
        {
            // Basic validation (e.g., not excessively long if there were a theoretical limit)
            // More complex validation (like JSON structure) might happen in Manager or AppService.
            FormDefinition = formDefinition;
        }

        private void SetTempPathInternal([CanBeNull] string? tempPath)
        {
            Check.Length(tempPath, nameof(tempPath), ComponentConsts.MaxTempPathLength);
            // Maybe validate path format?
            TempPath = tempPath;
        }

        /// <summary>
        /// Internal method to set the Type and ensure consistency of FormDefinition/TempPath.
        /// </summary>
        private void SetTypeAndContentInternal(ComponentType type, [CanBeNull] string? formDefinition, [CanBeNull] string? tempPath)
        {
            Type = type;
            if (type == ComponentType.Form)
            {
                // Validate FormDefinition is provided and TempPath is null/empty
                Check.NotNullOrWhiteSpace(formDefinition, nameof(formDefinition), message: "FormDefinition cannot be empty when component Type is Form."); // Must have definition if type is Form
                if (!string.IsNullOrWhiteSpace(tempPath))
                {
                     // Consider throwing a specific BusinessException with Error Code
                    throw new ArgumentException("TempPath must be null or empty when component Type is Form.", nameof(tempPath));
                }
                SetFormDefinitionInternal(formDefinition);
                SetTempPathInternal(null); // Ensure TempPath is cleared
            }
            else // Type is File
            {
                // Validate TempPath is provided and FormDefinition is null/empty
                Check.NotNullOrWhiteSpace(tempPath, nameof(tempPath), message: "TempPath cannot be empty when component Type is File."); // Must have path if type is File
                if (!string.IsNullOrWhiteSpace(formDefinition))
                {
                    // Consider throwing a specific BusinessException with Error Code
                   throw new ArgumentException("FormDefinition must be null or empty when component Type is File.", nameof(formDefinition));
                }
                 SetTempPathInternal(tempPath);
                 SetFormDefinitionInternal(null); // Ensure FormDefinition is cleared
            }
        }

        // --- Public methods to change state ---

        /// <summary>
        /// Changes the name of the component.
        /// </summary>
        public ProcedureComponent SetName([NotNull] string name)
        {
            SetNameInternal(name);
            return this;
        }

         /// <summary>
        /// Changes the display/processing order.
        /// </summary>
        public ProcedureComponent SetOrder(int order)
        {
            SetOrderInternal(order);
            return this;
        }

        /// <summary>
        /// Changes the description.
        /// </summary>
        public ProcedureComponent SetDescription([CanBeNull] string? description)
        {
            SetDescriptionInternal(description);
            return this;
        }

         /// <summary>
        /// Changes the type and associated content (FormDefinition or TempPath).
        /// Ensures validation rules based on the new type are met.
        /// </summary>
        public ProcedureComponent SetTypeAndContent(ComponentType type, [CanBeNull] string? formDefinition, [CanBeNull] string? tempPath)
        {
            SetTypeAndContentInternal(type, formDefinition, tempPath);
            return this;
        }


        /// <summary>
        /// Sets the component status to Active.
        /// </summary>
        public ProcedureComponent Activate()
        {
            Status = ComponentStatus.Active;
            return this;
        }

        /// <summary>
        /// Sets the component status to Inactive.
        /// </summary>
        public ProcedureComponent Deactivate()
        {
            Status = ComponentStatus.Inactive;
            return this;
        }

        // Note: No public SetCode method.

        // --- Methods to manage the ProcedureLinks collection ---
        // Called by ProcedureComponentManager
        internal void ClearProcedureLinks()
        {
            ProcedureLinks.Clear();
        }

        internal void AddProcedureLink(ProcedureComponentLink link) // Sử dụng tên mới ProcedureComponentLink
        {
            // Basic check to prevent adding null or duplicate links (based on object reference initially)
            Check.NotNull(link, nameof(link));
            if (!ProcedureLinks.Contains(link)) // Simple duplicate check
            {
                 ProcedureLinks.Add(link);
            }
            // More robust duplicate check based on composite key might be needed depending on usage pattern
        }
         internal void RemoveProcedureLink(ProcedureComponentLink link) // Sử dụng tên mới ProcedureComponentLink
        {
            Check.NotNull(link, nameof(link));
            ProcedureLinks.Remove(link);
        }
    }
    ```

## 1.1. Joining Entity (`ProcedureComponentLink.cs`)

**Mục đích:**

*   Đại diện cho mối quan hệ Nhiều-Nhiều giữa `Procedure` và `ProcedureComponent`.
*   Lưu trữ khóa ngoại tới hai Aggregate Roots liên quan. Entity này không phải là Aggregate Root.

**Cấu trúc `ProcedureComponentLink.cs`:**

-   **Vị trí:** `src/Aqt.CoreFW.Domain/Components/Entities/ProcedureComponentLink.cs` (Đổi tên file)
-   **Nội dung:**
    ```csharp
    using System;
    using Aqt.CoreFW.Domain.Procedures.Entities; // Namespace for Procedure entity
    using Volo.Abp.Domain.Entities; // Base class for entities

    namespace Aqt.CoreFW.Domain.Components.Entities;

    /// <summary>
    /// Joining entity representing the many-to-many relationship link
    /// between Procedure and ProcedureComponent.
    /// This entity uses a composite primary key (ProcedureId, ProcedureComponentId).
    /// </summary>
    public class ProcedureComponentLink : Entity // Using composite key managed by EF Core mapping
    {
        /// <summary>
        /// Foreign key to the Procedure. Part of the composite primary key.
        /// </summary>
        public virtual Guid ProcedureId { get; protected set; }

        /// <summary>
        /// Foreign key to the ProcedureComponent. Part of the composite primary key.
        /// </summary>
        public virtual Guid ProcedureComponentId { get; protected set; }

        // Optional: Navigation properties back to the aggregate roots
        // These should typically NOT be included here to avoid Aggregate boundary issues.
        // Load aggregates separately using their IDs if needed.
        // public virtual Procedure Procedure { get; set; }
        // public virtual ProcedureComponent ProcedureComponent { get; set; }

        /// <summary>
        /// Protected constructor for ORM.
        /// </summary>
        protected ProcedureComponentLink() { }

        /// <summary>
        /// Creates a new link between a Procedure and a ProcedureComponent.
        /// Should only be created via the ProcedureComponentManager.
        /// </summary>
        /// <param name="procedureId">ID of the Procedure.</param>
        /// <param name="procedureComponentId">ID of the ProcedureComponent.</param>
        internal ProcedureComponentLink(Guid procedureId, Guid procedureComponentId)
        {
            // Basic validation can be added if needed, e.g., check Guids are not empty.
            ProcedureId = procedureId;
            ProcedureComponentId = procedureComponentId;
        }

        /// <summary>
        /// Gets the composite key values.
        /// Used by ABP/EF Core to identify the entity.
        /// </summary>
        /// <returns>An array containing the key values.</returns>
        public override object[] GetKeys()
        {
            return new object[] { ProcedureId, ProcedureComponentId };
        }
    }
    ```

## 2. Repository Interface (`IProcedureComponentRepository.cs`)

-   **Vị trí:** `src/Aqt.CoreFW.Domain/Components/` (Tạo thư mục nếu chưa có)
-   **Tệp:** Tạo file `IProcedureComponentRepository.cs`
-   **Nội dung:**
    ```csharp
    using System;
    using System.Collections.Generic;
    using System.Threading;
    using System.Threading.Tasks;
    using Aqt.CoreFW.Components; // Namespace chứa Enum
    using Aqt.CoreFW.Domain.Components.Entities; // Namespace chứa Entity
    using JetBrains.Annotations;
    using Volo.Abp.Domain.Repositories;

    namespace Aqt.CoreFW.Domain.Components;

    /// <summary>
    /// Defines the repository interface for the ProcedureComponent aggregate root.
    /// Extends the basic IRepository and adds custom methods.
    /// </summary>
    public interface IProcedureComponentRepository : IRepository<ProcedureComponent, Guid> // Kế thừa IRepository cơ bản
    {
        /// <summary>
        /// Finds a ProcedureComponent by its unique code, optionally including details.
        /// </summary>
        /// <param name="code">The code to search for.</param>
        /// <param name="includeDetails">Whether to include navigation properties like ProcedureLinks. Defaults to true.</param>
        /// <param name="cancellationToken">Cancellation token.</param>
        /// <returns>The found ProcedureComponent or null.</returns>
        Task<ProcedureComponent?> FindByCodeAsync(
            [NotNull] string code,
            bool includeDetails = true, // Default true to include links when finding by code
            CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets a list of ProcedureComponents based on filtering and pagination criteria.
        /// </summary>
        /// <param name="filterText">Text to search in Code or Name.</param>
        /// <param name="code">Filter by exact code.</param>
        /// <param name="name">Filter by name containing text.</param>
        /// <param name="status">Filter by status.</param>
        /// <param name="type">Filter by component type.</param>
        /// <param name="procedureId">Optional: Filter by components linked to a specific Procedure.</param>
        /// <param name="sorting">Sorting expression (e.g., "Order ASC, Name DESC").</param>
        /// <param name="maxResultCount">Maximum number of results to return.</param>
        /// <param name="skipCount">Number of results to skip (for pagination).</param>
        /// <param name="includeDetails">Whether to include navigation properties like ProcedureLinks. Defaults to false for lists.</param>
        /// <param name="cancellationToken">Cancellation token.</param>
        /// <returns>A list of ProcedureComponents.</returns>
        Task<List<ProcedureComponent>> GetListAsync(
            string? filterText = null,
            string? code = null,
            string? name = null,
            ComponentStatus? status = null,
            ComponentType? type = null,
            Guid? procedureId = null, // Added filter by Procedure
            string? sorting = null,
            int maxResultCount = int.MaxValue,
            int skipCount = 0,
            bool includeDetails = false, // Default false for lists
            CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets the total count of ProcedureComponents based on filtering criteria.
        /// </summary>
        /// <param name="filterText">Text to search in Code or Name.</param>
        /// <param name="code">Filter by exact code.</param>
        /// <param name="name">Filter by name containing text.</param>
        /// <param name="status">Filter by status.</param>
        /// <param name="type">Filter by component type.</param>
        /// <param name="procedureId">Optional: Filter by components linked to a specific Procedure.</param>
        /// <param name="cancellationToken">Cancellation token.</param>
        /// <returns>The total count of matching ProcedureComponents.</returns>
        Task<long> GetCountAsync(
            string? filterText = null,
            string? code = null,
            string? name = null,
            ComponentStatus? status = null,
            ComponentType? type = null,
             Guid? procedureId = null, // Added filter by Procedure
            CancellationToken cancellationToken = default);

        /// <summary>
        /// Checks if a ProcedureComponent with the given code already exists, optionally excluding one ID.
        /// </summary>
        /// <param name="code">The code to check for uniqueness.</param>
        /// <param name="excludeId">Optional: Exclude this Component ID from the check (used during update).</param>
        /// <param name="cancellationToken">Cancellation token.</param>
        /// <returns>True if a component with the code exists (excluding the specified ID), false otherwise.</returns>
        Task<bool> CodeExistsAsync(
            [NotNull] string code,
            Guid? excludeId = null,
            CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets a list of Procedure IDs currently linked to a specific ProcedureComponent.
        /// </summary>
        /// <param name="componentId">The ID of the ProcedureComponent.</param>
        /// <param name="cancellationToken">Cancellation token.</param>
        /// <returns>A list of Guids representing the linked Procedure IDs.</returns>
        Task<List<Guid>> GetLinkedProcedureIdsAsync(
            Guid componentId,
            CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets the joining entities (ProcedureComponentLink) for a specific ProcedureComponent.
        /// This is primarily used internally by the ProcedureComponentManager to manage the links.
        /// </summary>
        /// <param name="componentId">The ID of the ProcedureComponent.</param>
        /// <param name="cancellationToken">Cancellation token.</param>
        /// <returns>A list of ProcedureComponentLink entities associated with the component.</returns>
        Task<List<ProcedureComponentLink>> GetComponentLinksAsync( // Đổi tên và kiểu trả về
            Guid componentId,
            CancellationToken cancellationToken = default);

        /// <summary>
        /// Removes multiple ProcedureComponentLink entities efficiently.
        /// This method should be implemented in the concrete repository (e.g., EF Core) for performance.
        /// </summary>
        /// <param name="links">The list of ProcedureComponentLink entities to delete.</param>
        /// <param name="autoSave">Whether to automatically save changes. Defaults to false.</param>
        /// <param name="cancellationToken">Cancellation token.</param>
        /// <returns>A task representing the asynchronous operation.</returns>
        Task DeleteManyComponentLinksAsync( // Đổi tên
             [NotNull] List<ProcedureComponentLink> links, // Đổi kiểu tham số, NotNull
             bool autoSave = false,
             CancellationToken cancellationToken = default);

        /// <summary>
        /// Inserts multiple ProcedureComponentLink entities efficiently.
        /// This method should be implemented in the concrete repository (e.g., EF Core) for performance.
        /// </summary>
        /// <param name="links">The list of ProcedureComponentLink entities to insert.</param>
        /// <param name="autoSave">Whether to automatically save changes. Defaults to false.</param>
        /// <param name="cancellationToken">Cancellation token.</param>
        /// <returns>A task representing the asynchronous operation.</returns>
        Task InsertManyComponentLinksAsync( // Đổi tên
             [NotNull] List<ProcedureComponentLink> links, // Đổi kiểu tham số, NotNull
             bool autoSave = false,
             CancellationToken cancellationToken = default);

         /// <summary>
        /// Gets a simplified list of Procedure Components for lookup purposes (e.g., dropdowns).
        /// </summary>
        /// <param name="type">Optional filter by component type.</param>
        /// <param name="onlyActive">Whether to return only active components. Defaults to true.</param>
        /// <param name="sorting">Sorting expression. Defaults to "Order ASC, Name ASC".</param>
        /// <param name="cancellationToken">Cancellation token.</param>
        /// <returns>A list of ProcedureComponents suitable for lookup.</returns>
        Task<List<ProcedureComponent>> GetLookupAsync(
            ComponentType? type = null,
            bool onlyActive = true,
            string? sorting = "Order ASC, Name ASC",
            CancellationToken cancellationToken = default);
    }
    ```

## 3. Domain Service (`ProcedureComponentManager.cs`)

**Trách nhiệm:**

*   Thực thi các quy tắc nghiệp vụ khi tạo (`CreateAsync`) và cập nhật (`UpdateAsync`) ProcedureComponents.
*   Đảm bảo tính nhất quán của dữ liệu, đặc biệt là mối liên hệ giữa `Type`, `FormDefinition`, và `TempPath`.
*   Kiểm tra tính duy nhất của `Code` trên toàn hệ thống.
*   Quản lý mối quan hệ Nhiều-Nhiều với `Procedure` bằng cách điều phối việc thêm/xóa các bản ghi `ProcedureComponentLink` (`UpdateProcedureLinksAsync`).
*   Validate sự tồn tại của các `Procedure` được liên kết tới.
*   Tương tác với `IProcedureComponentRepository`, `IRepository<ProcedureComponentLink>` và `IProcedureRepository`.

**Cấu trúc `ProcedureComponentManager.cs`:**

-   **Vị trí:** `src/Aqt.CoreFW.Domain/Components/`
-   **Tệp:** Tạo file `ProcedureComponentManager.cs`
-   **Nội dung:**
    ```csharp
    using System;
    using System.Collections.Generic;
    using System.Linq; // Required for LINQ operations
    using System.Threading.Tasks;
    using Aqt.CoreFW.Components; // Namespaces cần thiết
    using Aqt.CoreFW.Domain.Components.Entities;
    using Aqt.CoreFW.Domain.Procedures; // For IProcedureRepository
    using JetBrains.Annotations;
    using Volo.Abp;
    using Volo.Abp.Domain.Repositories; // For IRepository<ProcedureComponentLink>
    using Volo.Abp.Domain.Services;
    using Volo.Abp.Guids;
    using Volo.Abp.Domain.Entities; // For EntityNotFoundException
    // using Volo.Abp.Users; // Inject nếu cần CurrentUser

    namespace Aqt.CoreFW.Domain.Components;

    /// <summary>
    /// Domain service responsible for managing ProcedureComponent entities and their relationship with Procedures.
    /// </summary>
    public class ProcedureComponentManager : DomainService
    {
        private readonly IProcedureComponentRepository _componentRepository;
        // Inject the generic repository for the joining entity if specific methods aren't on IProcedureComponentRepository
        private readonly IRepository<ProcedureComponentLink> _procedureComponentLinkRepository;
        private readonly IProcedureRepository _procedureRepository; // To validate Procedure IDs exist
        private readonly IGuidGenerator _guidGenerator;
        // private readonly ICurrentUser _currentUser;

        public ProcedureComponentManager(
            IProcedureComponentRepository componentRepository,
            IRepository<ProcedureComponentLink> procedureComponentLinkRepository, // Inject repo với tên mới
            IProcedureRepository procedureRepository,
            IGuidGenerator guidGenerator/*,
            ICurrentUser currentUser*/)
        {
            _componentRepository = componentRepository;
            _procedureComponentLinkRepository = procedureComponentLinkRepository; // Gán repo với tên mới
            _procedureRepository = procedureRepository;
            _guidGenerator = guidGenerator;
            // _currentUser = currentUser;
        }

        /// <summary>
        /// Creates a new ProcedureComponent entity after validating business rules.
        /// The Application Service is responsible for inserting the returned entity.
        /// </summary>
        /// <param name="code">Unique code.</param>
        /// <param name="name">Name.</param>
        /// <param name="order">Display order.</param>
        /// <param name="type">Component type.</param>
        /// <param name="formDefinition">Form definition (required and validated if type is Form).</param>
        /// <param name="tempPath">Template path (required and validated if type is File).</param>
        /// <param name="description">Optional description.</param>
        /// <param name="status">Initial status.</param>
        /// <returns>The newly created, validated ProcedureComponent entity (not yet persisted).</returns>
        /// <exception cref="UserFriendlyException">Thrown if Code already exists.</exception>
        /// <exception cref="ArgumentException">Thrown if type/content mismatch or other invalid arguments.</exception>
        public async Task<ProcedureComponent> CreateAsync(
            [NotNull] string code,
            [NotNull] string name,
            int order,
            ComponentType type,
            [CanBeNull] string? formDefinition = null,
            [CanBeNull] string? tempPath = null,
            [CanBeNull] string? description = null,
            ComponentStatus status = ComponentStatus.Active)
        {
            // Basic argument checks using Volo.Abp.Check
            Check.NotNullOrWhiteSpace(code, nameof(code), ComponentConsts.MaxCodeLength);
            Check.NotNullOrWhiteSpace(name, nameof(name), ComponentConsts.MaxNameLength);
            Check.Length(description, nameof(description), ComponentConsts.MaxDescriptionLength);
            // Order validation if needed (e.g., >= 0)
            // Check.Range(order, nameof(order), 0);

            // Validate Code uniqueness (business rule)
            await ValidateCodeUniquenessAsync(code);

            // Validate Type and content consistency (business rule)
            ValidateTypeAndContentConsistency(type, formDefinition, tempPath);
            // Optional: Validate FormDefinition JSON or TempPath format here if desired

            // Use internal constructor of the entity - this ensures the entity is created in a valid state
            var component = new ProcedureComponent(
                _guidGenerator.Create(),
                code,
                name,
                order,
                type,
                formDefinition, // Pass validated values
                tempPath,       // Pass validated values
                description,
                status
            );

            // Return the new entity; Application Service handles InsertAsync
            return component;
        }

        /// <summary>
        /// Updates an existing ProcedureComponent entity after validating business rules.
        /// The Application Service is responsible for updating the entity in the repository.
        /// Note: The component's Code cannot be changed.
        /// </summary>
        /// <param name="component">The existing ProcedureComponent entity to update.</param>
        /// <param name="name">New name.</param>
        /// <param name="order">New display order.</param>
        /// <param name="type">New component type.</param>
        /// <param name="formDefinition">New form definition (validated based on type).</param>
        /// <param name="tempPath">New template path (validated based on type).</param>
        /// <param name="description">New optional description.</param>
        /// <param name="status">New status.</param>
        /// <returns>The updated ProcedureComponent entity (not yet persisted).</returns>
        /// <exception cref="ArgumentNullException">Thrown if component is null.</exception>
        /// <exception cref="ArgumentException">Thrown if type/content mismatch or other invalid arguments.</exception>
        public Task<ProcedureComponent> UpdateAsync(
            [NotNull] ProcedureComponent component,
            [NotNull] string name,
            int order,
            ComponentType type,
            [CanBeNull] string? formDefinition,
            [CanBeNull] string? tempPath,
            [CanBeNull] string? description,
            ComponentStatus status)
        {
            Check.NotNull(component, nameof(component)); // Ensure entity exists

            // Basic argument checks
            Check.NotNullOrWhiteSpace(name, nameof(name), ComponentConsts.MaxNameLength);
            Check.Length(description, nameof(description), ComponentConsts.MaxDescriptionLength);
            // Check.Range(order, nameof(order), 0); // If needed

            // Validate Type and content consistency before attempting to update
            ValidateTypeAndContentConsistency(type, formDefinition, tempPath);
            // Optional: Validate FormDefinition JSON or TempPath format here

            // Update properties using the entity's public methods to ensure encapsulation and validation
            component.SetName(name);
            component.SetOrder(order);
            component.SetDescription(description);
            component.SetTypeAndContent(type, formDefinition, tempPath); // Entity handles internal consistency

            // Update status
            if (status == ComponentStatus.Active)
            {
                component.Activate();
            }
            else
            {
                component.Deactivate();
            }

            // Return the modified entity; Application Service handles UpdateAsync
            // No async operations within this standard update logic, so Task.FromResult is fine.
            return Task.FromResult(component);
        }

        /// <summary>
        /// Updates the links between a specific ProcedureComponent and Procedures.
        /// It synchronizes the links in the database with the provided list of Procedure IDs.
        /// </summary>
        /// <param name="componentId">The ID of the ProcedureComponent whose links are to be updated.</param>
        /// <param name="procedureIds">The complete list of Procedure IDs that should be linked to the component.</param>
        /// <exception cref="EntityNotFoundException">Thrown if the ProcedureComponent with componentId does not exist.</exception>
        /// <exception cref="UserFriendlyException">Thrown if any of the provided procedureIds do not correspond to existing Procedures.</exception>
        public async Task UpdateProcedureLinksAsync(Guid componentId, [NotNull] List<Guid> procedureIds)
        {
             // Ensure the input list is not null
             Check.NotNull(procedureIds, nameof(procedureIds));
             // Work with distinct IDs to avoid potential issues
             var distinctProcedureIds = procedureIds.Distinct().ToList();

            // 1. Verify the ProcedureComponent exists (essential)
            // Finding the component also implicitly checks if componentId is valid.
            // We don't necessarily need the full component object here if we trust componentId,
            // but finding it ensures it exists before proceeding.
            var componentExists = await _componentRepository.AnyAsync(c => c.Id == componentId);
            if (!componentExists)
            {
                throw new EntityNotFoundException(typeof(ProcedureComponent), componentId);
            }

            // 2. Validate all provided Procedure IDs correspond to existing Procedures.
            if (distinctProcedureIds.Any())
            {
                 // Use the most efficient method available on IProcedureRepository
                 // Assuming GetCountAsync accepting a list of IDs is available:
                 var existingProceduresCount = await _procedureRepository.GetCountAsync(ids: distinctProcedureIds); // Modify signature as per IProcedureRepository impl.
                 if (existingProceduresCount != distinctProcedureIds.Count)
                 {
                      // Provide a user-friendly error message
                      throw new UserFriendlyException(L["OneOrMoreProceduresNotFound"]); // Define this localization key
                      // Alternative: Throw a BusinessException with more details if needed.
                 }
            }

            // 3. Get the current links from the database for this component.
            // Use the specific method from IProcedureComponentRepository for clarity and potential optimization.
            var currentLinks = await _componentRepository.GetComponentLinksAsync(componentId);
            var currentProcedureIds = currentLinks.Select(l => l.ProcedureId).ToList();

            // 4. Determine which links to add and which to remove.
            var procedureIdsToAdd = distinctProcedureIds.Except(currentProcedureIds).ToList();
            var linksToRemove = currentLinks.Where(l => !distinctProcedureIds.Contains(l.ProcedureId)).ToList();

            // 5. Remove the links that are no longer needed.
            if (linksToRemove.Any())
            {
                 // Prefer specific repository method for potential batch operations.
                 // Fallback to generic repository if the specific method is not implemented.
                 try
                 {
                    await _componentRepository.DeleteManyComponentLinksAsync(linksToRemove, true);
                 }
                 catch (NotImplementedException) // Example fallback
                 {
                    await _procedureComponentLinkRepository.DeleteManyAsync(linksToRemove, true);
                 }
            }

            // 6. Add the new links.
            if (procedureIdsToAdd.Any())
            {
                 var newLinks = procedureIdsToAdd
                     .Select(procId => new ProcedureComponentLink(procId, componentId)) // Create new link entities
                     .ToList();

                 // Prefer specific repository method for potential batch operations.
                 // Fallback to generic repository.
                  try
                 {
                    await _componentRepository.InsertManyComponentLinksAsync(newLinks, true);
                 }
                 catch (NotImplementedException) // Example fallback
                 {
                    await _procedureComponentLinkRepository.InsertManyAsync(newLinks, true);
                 }
            }
            // Changes are saved via autoSave=true or by the UnitOfWork in the AppService.
        }


        /// <summary>
        /// Private helper method to validate the uniqueness of the ProcedureComponent code.
        /// Throws a UserFriendlyException if the code already exists (excluding the given ID).
        /// </summary>
        private async Task ValidateCodeUniquenessAsync([NotNull] string code, Guid? excludeId = null)
        {
             // Use the dedicated repository method
             if (await _componentRepository.CodeExistsAsync(code, excludeId))
            {
                // Use a localized error message defined in Domain.Shared
                throw new UserFriendlyException(L["ComponentCodeAlreadyExists", code]);
                // Alternative using BusinessException with Error Code:
                // throw new BusinessException(CoreFWDomainErrorCodes.ComponentCodeAlreadyExists).WithData("code", code);
            }
        }

        /// <summary>
        /// Private helper method to validate the consistency between Type, FormDefinition, and TempPath.
        /// Throws ArgumentException if rules are violated.
        /// </summary>
        private void ValidateTypeAndContentConsistency(ComponentType type, [CanBeNull] string? formDefinition, [CanBeNull] string? tempPath)
        {
            // This logic is crucial and mirrors the entity's internal checks.
            // It prevents invalid combinations before attempting to set them on the entity.
             if (type == ComponentType.Form)
            {
                // If Type is Form, FormDefinition must have a value.
                if (string.IsNullOrWhiteSpace(formDefinition))
                {
                    throw new ArgumentException("FormDefinition cannot be empty when component Type is Form.", nameof(formDefinition));
                    // Consider BusinessException with specific error code if needed
                }
                // If Type is Form, TempPath must be null or empty.
                 if (!string.IsNullOrWhiteSpace(tempPath))
                {
                     throw new ArgumentException("TempPath must be empty when component Type is Form.", nameof(tempPath));
                 }
                 // Optional: Add JSON format validation for FormDefinition
                 // try
                 // {
                 //    if(formDefinition != null) System.Text.Json.JsonDocument.Parse(formDefinition);
                 // }
                 // catch (System.Text.Json.JsonException ex)
                 // {
                 //    throw new ArgumentException($"FormDefinition is not valid JSON: {ex.Message}", nameof(formDefinition));
                 // }
            }
            else // Type == ComponentType.File
            {
                // If Type is File, TempPath must have a value.
                if (string.IsNullOrWhiteSpace(tempPath))
                {
                   throw new ArgumentException("TempPath cannot be empty when component Type is File.", nameof(tempPath));
                }
                // If Type is File, FormDefinition must be null or empty.
                 if (!string.IsNullOrWhiteSpace(formDefinition))
                {
                    throw new ArgumentException("FormDefinition must be empty when component Type is File.", nameof(formDefinition));
                 }
                 // Optional: Add path format validation for TempPath
                 // Example: Check for invalid characters, URI format, etc.
            }
        }
    }
    ```

## 4. Cập nhật `CoreFWDomainModule.cs`

-   **Vị trí:** `src/Aqt.CoreFW.Domain/CoreFWDomainModule.cs`
-   **Hành động:** **Không cần thay đổi.** ABP Framework tự động quét và đăng ký các Domain Services (`ProcedureComponentManager`) và Repositories (`IProcedureComponentRepository`, `IRepository<ProcedureComponentLink>`) được định nghĩa trong assembly này.

## 5. Lưu ý

*   **Tính duy nhất của `Code`:** Logic kiểm tra tính duy nhất được thực hiện trong `ProcedureComponentManager` thông qua `ValidateCodeUniquenessAsync`, sử dụng phương thức `CodeExistsAsync` của `IProcedureComponentRepository`.
*   **Aggregate Root:** `ProcedureComponent` được thiết kế là Aggregate Root chính cho module này. `ProcedureComponentLink` là một Entity thông thường đại diện cho liên kết Nhiều-Nhiều, không phải Aggregate Root.
*   **Quan hệ Nhiều-Nhiều:**
    *   Sử dụng bảng trung gian `ProcedureComponentLink`.
    *   `ProcedureComponentManager` (`UpdateProcedureLinksAsync`) điều phối việc cập nhật các liên kết, đảm bảo tính nhất quán bằng cách xóa các liên kết cũ và thêm các liên kết mới.
    *   Việc validate sự tồn tại của các `Procedure` được liên kết là rất quan trọng và được thực hiện bằng cách gọi `_procedureRepository.GetCountAsync(ids: ...)` hoặc phương thức tương tự.
    *   `IProcedureComponentRepository` nên bao gồm các phương thức tối ưu hóa (`DeleteManyComponentLinksAsync`, `InsertManyComponentLinksAsync`) để xử lý batch các liên kết. Nếu không, `ProcedureComponentManager` có thể sử dụng `IRepository<ProcedureComponentLink>` chung.
*   **Validation Type/Content:** Logic kiểm tra sự nhất quán giữa `Type`, `FormDefinition`, và `TempPath` được đặt trong cả Entity (`SetTypeAndContentInternal`) và Domain Service (`ValidateTypeAndContentConsistency`). Việc kiểm tra trong Domain Service giúp phát hiện lỗi sớm trước khi cố gắng cập nhật Entity. Cân nhắc bổ sung validation định dạng (JSON, path) nếu cần.
*   **Error Handling:** Sử dụng `UserFriendlyException` (với localization key `L[...]`) cho các lỗi nghiệp vụ cần hiển thị cho người dùng. Sử dụng `ArgumentException` cho các lỗi tham số đầu vào không hợp lệ. Sử dụng `EntityNotFoundException` khi không tìm thấy Aggregate Root. Cân nhắc sử dụng `BusinessException` với mã lỗi cụ thể từ `CoreFWDomainErrorCodes` cho các quy tắc nghiệp vụ phức tạp hơn.
*   **Repository Dependency:** `ProcedureComponentManager` phụ thuộc vào `IProcedureComponentRepository` (repository chính), `IRepository<ProcedureComponentLink>` (repository cho bảng liên kết - có thể thay bằng các phương thức trong `IProcedureComponentRepository`), `IProcedureRepository` (để validation), và các dịch vụ ABP cơ bản như `IGuidGenerator`.