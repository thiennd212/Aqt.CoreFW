# Kế hoạch chi tiết: Tầng EntityFrameworkCore (`Aqt.CoreFW.EntityFrameworkCore`) - Quản lý Danh mục Dữ liệu Cốt lõi (DataCore Management)

Phần này mô tả các thành phần cần tạo hoặc cập nhật trong tầng `Aqt.CoreFW.EntityFrameworkCore` cho module Quản lý Danh mục Dữ liệu Cốt lõi (DataCore).

## 1. DbContext

-   **Vị trí:** Cập nhật file `src/Aqt.CoreFW.EntityFrameworkCore/EntityFrameworkCore/CoreFWDbContext.cs`
-   **Nội dung cần thêm:**
    ```csharp
    using Aqt.CoreFW.Domain.DataCores.Entities; // Thêm using cho DataCore Entity
    using Microsoft.EntityFrameworkCore;
    using System.Reflection;
    // ... other usings ...

    public class CoreFWDbContext : AbpDbContext<CoreFWDbContext>, /* ... các interface khác ... */
    {
        // ... các DbSet khác (DataGroup, Province, District, etc.) ...
        public DbSet<DataCore> DataCores { get; set; } // Thêm DbSet cho DataCore


        public CoreFWDbContext(DbContextOptions<CoreFWDbContext> options)
            : base(options)
        {
        }

        protected override void OnModelCreating(ModelBuilder builder)
        {
            base.OnModelCreating(builder);

            // Cấu hình các module khác của ABP...
            // ...

            // Áp dụng tất cả cấu hình entity trong assembly này
            builder.ApplyConfigurationsFromAssembly(Assembly.GetExecutingAssembly());
        }
    }
    ```

## 2. Entity Configuration (`DataCoreConfiguration.cs`)

-   **Vị trí:** Tạo thư mục `src/Aqt.CoreFW.EntityFrameworkCore/EntityTypeConfigurations/DataCores` (Tạo thư mục nếu chưa có)
-   **Tệp:** Tạo file `DataCoreConfiguration.cs`
-   **Nội dung:**
    ```csharp
    using Aqt.CoreFW.Domain.DataCores.Entities; // DataCore Entity
    using Aqt.CoreFW.Domain.DataGroups.Entities; // DataGroup Entity for FK relation
    using Aqt.CoreFW.Domain.Shared; // Namespace chứa CoreFWConsts
    using Aqt.CoreFW.DataCores; // Namespace chứa DataCoreConsts và DataCoreStatus enum
    using Microsoft.EntityFrameworkCore;
    using Microsoft.EntityFrameworkCore.Metadata.Builders;
    using Volo.Abp.EntityFrameworkCore.Modeling;

    namespace Aqt.CoreFW.EntityFrameworkCore.EntityTypeConfigurations.DataCores; // Namespace Configuration

    /// <summary>
    /// Configures the database mapping for the <see cref="DataCore"/> entity.
    /// </summary>
    public class DataCoreConfiguration : IEntityTypeConfiguration<DataCore>
    {
        public void Configure(EntityTypeBuilder<DataCore> builder)
        {
            // Sử dụng DbTablePrefix và DbSchema từ CoreFWConsts
            builder.ToTable(CoreFWConsts.DbTablePrefix + "DataCores", CoreFWConsts.DbSchema);

            builder.ConfigureByConvention(); // Áp dụng các quy ước chuẩn của ABP

            builder.HasKey(x => x.Id);

            // --- Property Configurations ---
            builder.Property(x => x.Code)
                .IsRequired()
                .HasMaxLength(DataCoreConsts.MaxCodeLength)
                .HasColumnName(nameof(DataCore.Code));

            builder.Property(x => x.Name)
                .IsRequired()
                .HasMaxLength(DataCoreConsts.MaxNameLength)
                .HasColumnName(nameof(DataCore.Name));

            builder.Property(x => x.Status)
                .IsRequired()
                .HasColumnName(nameof(DataCore.Status))
                .HasConversion<byte>(); // Map enum sang byte

            builder.Property(x => x.Order)
                .IsRequired()
                .HasColumnName(nameof(DataCore.Order));

            builder.Property(x => x.Description)
                .HasMaxLength(DataCoreConsts.MaxDescriptionLength)
                .HasColumnName(nameof(DataCore.Description));

            // DataGroupId là Guid bắt buộc
            builder.Property(x => x.DataGroupId)
                .IsRequired()
                .HasColumnName(nameof(DataCore.DataGroupId));

            // --- Foreign Keys ---
            builder.HasOne<DataGroup>() // Không cần chỉ định navigation property 'DataGroup' nếu không có trong Entity
                   .WithMany() // Một DataGroup có thể có nhiều DataCore
                   .HasForeignKey(x => x.DataGroupId)
                   .IsRequired() // Đảm bảo FK là bắt buộc
                   .OnDelete(DeleteBehavior.Restrict); // Quan trọng: Ngăn chặn việc xóa DataGroup nếu còn DataCore tham chiếu

            // --- Indexes ---

            // Index cho Code (Xem xét unique constraint: toàn cục hay theo DataGroupId)
            // Nếu unique toàn cục:
            builder.HasIndex(x => x.Code)
                   .IsUnique()
                   .HasDatabaseName($"IX_{CoreFWConsts.DbTablePrefix}DataCores_Code");
            // Nếu unique theo DataGroupId:
            // builder.HasIndex(x => new { x.DataGroupId, x.Code })
            //        .IsUnique()
            //        .HasDatabaseName($"IX_{CoreFWConsts.DbTablePrefix}DataCores_DataGroupId_Code");

            builder.HasIndex(x => x.Name)
                   .HasDatabaseName($"IX_{CoreFWConsts.DbTablePrefix}DataCores_Name");

            builder.HasIndex(x => x.Status)
                   .HasDatabaseName($"IX_{CoreFWConsts.DbTablePrefix}DataCores_Status");

            // Index trên DataGroupId để tăng tốc lọc theo nhóm
            builder.HasIndex(x => x.DataGroupId)
                  .HasDatabaseName($"IX_{CoreFWConsts.DbTablePrefix}DataCores_DataGroupId");

            // Index kết hợp cho sắp xếp/lọc phổ biến trong cùng nhóm
            builder.HasIndex(x => new { x.DataGroupId, x.Status, x.Order, x.Name })
                  .HasDatabaseName($"IX_{CoreFWConsts.DbTablePrefix}DataCores_DataGroupId_Status_Order_Name");
        }
    }
    ```

## 3. Repository Implementation (`DataCoreRepository.cs`)

-   **Vị trí:** Tạo thư mục `src/Aqt.CoreFW.EntityFrameworkCore/Repositories/DataCores` (Tạo thư mục nếu chưa có)
-   **Tệp:** Tạo file `DataCoreRepository.cs` bên trong thư mục trên
-   **Nội dung:**
    ```csharp
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Linq.Dynamic.Core;
    using System.Threading;
    using System.Threading.Tasks;
    using Aqt.CoreFW.Domain.DataCores; // IDataCoreRepository
    using Aqt.CoreFW.Domain.DataCores.Entities; // DataCore Entity
    using Aqt.CoreFW.EntityFrameworkCore; // CoreFWDbContext, EfCoreRepository
    using Aqt.CoreFW.DataCores; // DataCoreStatus enum
    using Microsoft.EntityFrameworkCore;
    using Volo.Abp.Domain.Repositories.EntityFrameworkCore;
    using Volo.Abp.EntityFrameworkCore;

    namespace Aqt.CoreFW.EntityFrameworkCore.Repositories.DataCores;

    public class DataCoreRepository :
        EfCoreRepository<CoreFWDbContext, DataCore, Guid>,
        IDataCoreRepository
    {
        public DataCoreRepository(IDbContextProvider<CoreFWDbContext> dbContextProvider)
            : base(dbContextProvider)
        {
        }

        public async Task<DataCore?> FindByCodeAsync(string code, bool includeDetails = false, CancellationToken cancellationToken = default)
        {
            // Nếu Code unique toàn cục:
            var dbSet = await GetDbSetAsync();
            // Include details is typically not needed unless a navigation property is used
            return await dbSet.AsNoTracking()
                              .FirstOrDefaultAsync(dc => dc.Code == code, GetCancellationToken(cancellationToken));

            // Nếu Code unique theo DataGroupId, hàm này cần thêm dataGroupId và logic Where phức tạp hơn
            // Consider throwing an exception or changing the method signature if global uniqueness is not guaranteed.
        }

        // public async Task<DataCore?> FindByCodeAsync(string code, Guid dataGroupId, bool includeDetails = false, CancellationToken cancellationToken = default)
        // {
        //     // Nếu Code unique theo DataGroupId:
        //     var dbSet = await GetDbSetAsync();
        //     return await dbSet.AsNoTracking()
        //                       .FirstOrDefaultAsync(dc => dc.DataGroupId == dataGroupId && dc.Code == code, GetCancellationToken(cancellationToken));
        // }

        public async Task<bool> CodeExistsAsync(string code, Guid? dataGroupId = null, Guid? excludeId = null, CancellationToken cancellationToken = default)
        {
            var dbSet = await GetDbSetAsync();
            var query = dbSet.AsNoTracking();

            // Nếu check unique toàn cục:
            if (!dataGroupId.HasValue)
            {
                query = query.Where(dc => dc.Code == code);
            }
            // Nếu check unique theo DataGroupId:
            else
            {
                query = query.Where(dc => dc.DataGroupId == dataGroupId.Value && dc.Code == code);
            }

            if (excludeId.HasValue)
            {
                query = query.Where(dc => dc.Id != excludeId.Value);
            }

            return await query.AnyAsync(GetCancellationToken(cancellationToken));
        }

        public async Task<List<DataCore>> GetListAsync(
            string? filterText = null,
            string? code = null,
            string? name = null,
            DataCoreStatus? status = null,
            Guid? dataGroupId = null,
            string? sorting = null,
            int maxResultCount = int.MaxValue,
            int skipCount = 0,
            CancellationToken cancellationToken = default) // Bỏ includeDetails vì không có navigation prop điển hình
        {
            var query = await GetListQueryInternalAsync(filterText, code, name, status, dataGroupId);

            query = query.OrderBy(sorting.IsNullOrWhiteSpace() ?
                $"{nameof(DataCore.Order)} asc, {nameof(DataCore.Name)} asc" // Default sort
                : sorting);

            return await query.PageBy(skipCount, maxResultCount)
                              .ToListAsync(GetCancellationToken(cancellationToken));
        }

        public async Task<long> GetCountAsync(
            string? filterText = null,
            string? code = null,
            string? name = null,
            DataCoreStatus? status = null,
            Guid? dataGroupId = null,
            CancellationToken cancellationToken = default)
        {
            var query = await GetListQueryInternalAsync(filterText, code, name, status, dataGroupId);
            return await query.LongCountAsync(GetCancellationToken(cancellationToken));
        }

        public async Task<List<DataCore>> GetListByDataGroupIdAsync(
            Guid dataGroupId,
            bool onlyActive = true,
            string? sorting = null,
            CancellationToken cancellationToken = default)
        {
            var dbSet = await GetDbSetAsync();
            var query = dbSet.AsNoTracking().Where(dc => dc.DataGroupId == dataGroupId);

            if (onlyActive)
            {
                query = query.Where(dc => dc.Status == DataCoreStatus.Active);
            }

            query = query.OrderBy(sorting.IsNullOrWhiteSpace() ?
                 $"{nameof(DataCore.Order)} asc, {nameof(DataCore.Name)} asc" // Default sort for lookups
                 : sorting);

            // No pagination needed for typical lookup scenarios
            return await query.ToListAsync(GetCancellationToken(cancellationToken));
        }

        // --- Private Helper Methods ---

        private async Task<IQueryable<DataCore>> GetListQueryInternalAsync(
            string? filterText = null,
            string? code = null,
            string? name = null,
            DataCoreStatus? status = null,
            Guid? dataGroupId = null)
        {
            var dbSet = await GetDbSetAsync();
            return dbSet.AsNoTracking()
                .WhereIf(!filterText.IsNullOrWhiteSpace(), dc =>
                    (dc.Code != null && dc.Code.Contains(filterText!)) ||
                    (dc.Name != null && dc.Name.Contains(filterText!)))
                .WhereIf(!code.IsNullOrWhiteSpace(), dc => dc.Code == code)
                .WhereIf(!name.IsNullOrWhiteSpace(), dc => dc.Name != null && dc.Name.Contains(name))
                .WhereIf(status.HasValue, dc => dc.Status == status!.Value)
                .WhereIf(dataGroupId.HasValue, dc => dc.DataGroupId == dataGroupId!.Value);
        }
    }
    ```

## 4. Cập nhật `CoreFWDbContextModelCreatingExtensions.cs` (Không bắt buộc nếu dùng `ApplyConfigurationsFromAssembly`)

-   **Vị trí:** `src/Aqt.CoreFW.EntityFrameworkCore/EntityFrameworkCore/CoreFWDbContextModelCreatingExtensions.cs`
-   **Hành động:** Nếu bạn **không** sử dụng `builder.ApplyConfigurationsFromAssembly(Assembly.GetExecutingAssembly());` trong `CoreFWDbContext.OnModelCreating`, bạn cần gọi thủ công phương thức cấu hình cho `DataCore` tại đây.
    ```csharp
    public static void ConfigureCoreFW(this ModelBuilder builder)
    {
        Check.NotNull(builder, nameof(builder));

        // ... Cấu hình cho các entity khác (Province, District, Commune, Rank, DataGroup) ...

        // Cấu hình cho DataCore
        builder.ApplyConfiguration(new Aqt.CoreFW.EntityFrameworkCore.EntityTypeConfigurations.DataCores.DataCoreConfiguration());

        // ... các cấu hình khác ...
    }
    ```
    **Khuyến nghị:** Sử dụng `ApplyConfigurationsFromAssembly` để tự động áp dụng tất cả cấu hình, giúp giảm thiểu việc cập nhật file này.

## 5. Database Migrations

-   **Hành động:**
    1.  **Thêm Migration:** Mở Package Manager Console (PMC) hoặc terminal, chọn project `Aqt.CoreFW.EntityFrameworkCore` làm project mặc định.
        ```bash
        dotnet ef migrations add Added_DataCore_Module
        ```
        *(Sử dụng tên migration mô tả, ví dụ: `Added_DataCore_Module`, `Added_DataCores_Table`)*
    2.  **Kiểm tra Migration:** Mở file migration mới được tạo trong thư mục `Migrations` của project `Aqt.CoreFW.EntityFrameworkCore` để xem lại các thay đổi SQL được tạo ra (tạo bảng `DataCores`, thêm cột, khóa ngoại, index).
    3.  **Cập nhật Database:**
        ```bash
        dotnet ef database update
        ```

## 6. Lưu ý

*   **Namespace:** Đảm bảo các namespace là chính xác cho Entity, Enum, Constants, Configuration, Repository và DbContext.
*   **Code Uniqueness:** Cần xác nhận lại yêu cầu về tính duy nhất của `DataCore.Code` (toàn cục hay theo `DataGroupId`) và cấu hình Index tương ứng trong `DataCoreConfiguration` cũng như logic trong `DataCoreRepository.FindByCodeAsync` và `DataCoreRepository.CodeExistsAsync`.
*   **Foreign Key Constraint:** Đã cấu hình `OnDelete(DeleteBehavior.Restrict)` cho khóa ngoại `DataGroupId` để ngăn xóa `DataGroup` nếu còn `DataCore` liên quan.
*   **Indexes:** Đã thêm các index cần thiết cho việc tìm kiếm, lọc và sắp xếp hiệu quả.
*   **Repository Implementation:** Repository triển khai các phương thức trong `IDataCoreRepository`, sử dụng LINQ và `IQueryable` để xây dựng truy vấn động. `GetListByDataGroupIdAsync` được tối ưu cho việc lấy lookup.
*   **Raw SQL:** Tránh sử dụng Raw SQL trong repository nếu có thể giải quyết bằng LINQ. Nếu bắt buộc (ví dụ: truy vấn đệ quy phức tạp), cần cẩn thận về bảo mật và tính tương thích database.
*   **Migrations:** Luôn tạo và kiểm tra migration cẩn thận trước khi cập nhật database. 