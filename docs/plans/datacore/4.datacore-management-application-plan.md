# Kế hoạch chi tiết: Tầng Application (`Aqt.CoreFW.Application`) - Quản lý Danh mục Dữ liệu Cốt lõi (DataCore Management)

Phần này mô tả các thành phần cần tạo hoặc cập nhật trong tầng `Aqt.CoreFW.Application` cho module Quản lý Danh mục Dữ liệu Cốt lõi (DataCore).

## 1. Mapping Logic

### 1.1. Mapping Action for Excel Export (`DataCoreToExcelMappingAction`)

-   **Mục đích:** Xử lý logic mapping tùy chỉnh khi chuyển đổi từ `DataCore` (Entity) sang `DataCoreExcelDto`, bao gồm địa phương hóa `Status`, và lấy thông tin `DataGroupCode`, `DataGroupName`.
-   **Vị trí:** Tạo thư mục `src/Aqt.CoreFW.Application/DataCores` (nếu chưa có)
-   **Tệp:** Tạo file `DataCoreToExcelMappingAction.cs` (Nếu có chức năng Export Excel)
-   **Nội dung:**
    ```csharp
    using System.Threading.Tasks; // Needed for async operations
    using Aqt.CoreFW.Application.Contracts.DataCores.Dtos; // DataCoreExcelDto
    using Aqt.CoreFW.Domain.DataCores.Entities; // DataCore Entity
    using Aqt.CoreFW.Domain.DataGroups; // IDataGroupRepository
    using Aqt.CoreFW.Domain.DataGroups.Entities;
    using Aqt.CoreFW.Localization; // CoreFWResource for L[]
    using AutoMapper;
    using Microsoft.Extensions.Localization; // Required for IStringLocalizer
    using Volo.Abp.DependencyInjection; // Required for ITransientDependency
    using Volo.Abp.Domain.Repositories;

    namespace Aqt.CoreFW.Application.DataCores; // Namespace for DataCore Application layer

    /// <summary>
    /// AutoMapper mapping action to handle specific logic when mapping
    /// from DataCore entity to DataCoreExcelDto.
    /// Handles localization of the Status enum and populates DataGroup details.
    /// </summary>
    public class DataCoreToExcelMappingAction
        : IMappingAction<DataCore, DataCoreExcelDto>, ITransientDependency
    {
        private readonly IStringLocalizer<CoreFWResource> _localizer;
        private readonly IRepository<DataGroup, Guid> _dataGroupRepository; // Inject basic repository

        public DataCoreToExcelMappingAction(
            IStringLocalizer<CoreFWResource> localizer,
            IRepository<DataGroup, Guid> dataGroupRepository)
        {
            _localizer = localizer;
            _dataGroupRepository = dataGroupRepository;
        }

        // Process method cannot be async directly in IMappingAction.
        // Fetching DataGroup data here synchronously is not ideal.
        // Best Practice: Populate DataGroupCode/Name in the AppService *before* mapping to Excel DTO.
        // Let's focus on StatusText localization here for demonstration.
        public void Process(DataCore source, DataCoreExcelDto destination, ResolutionContext context)
        {
            // Localize the Status enum
            destination.StatusText = _localizer[$"Enum:DataCoreStatus.{(int)source.Status}"];

            // Fetching DataGroup Name/Code here can lead to N+1 query issues.
            // It's better handled in the AppService GetListAsExcelAsync method.
            // Example (Not Recommended Here):
            // var dataGroup = _dataGroupRepository.Find(source.DataGroupId);
            // if (dataGroup != null)
            // {
            //     destination.DataGroupCode = dataGroup.Code;
            //     destination.DataGroupName = dataGroup.Name;
            // }
        }
    }
    ```
    **Lưu ý:** Việc lấy `DataGroupCode` và `DataGroupName` trong Mapping Action có thể gây vấn đề hiệu năng (N+1 query). Cách tốt hơn là xử lý việc này trong `DataCoreAppService.GetListAsExcelAsync` trước khi gọi `ObjectMapper.Map`.

### 1.2. AutoMapper Profile (`DataCoreApplicationAutoMapperProfile`)

-   **Vị trí:** Tạo file `src/Aqt.CoreFW.Application/DataCores/DataCoreApplicationAutoMapperProfile.cs`
-   **Nội dung:**
    ```csharp
    using Aqt.CoreFW.Application.Contracts.DataCores.Dtos; // DTOs for DataCore
    using Aqt.CoreFW.Application.Contracts.Shared.Lookups; // Lookup DTOs
    using Aqt.CoreFW.Domain.DataCores.Entities; // DataCore Entity
    using Aqt.CoreFW.Domain.DataGroups.Entities; // DataGroup Entity (for lookup mapping)
    using AutoMapper;

    namespace Aqt.CoreFW.Application.DataCores; // Namespace for DataCore Application layer

    public class DataCoreApplicationAutoMapperProfile : Profile
    {
        public DataCoreApplicationAutoMapperProfile()
        {
            // --- DataCore Mappings ---
            CreateMap<DataCore, DataCoreDto>()
                // Ignore DataGroupName/DataGroupCode, will be populated in AppService GetList/Get
                .ForMember(dest => dest.DataGroupName, opt => opt.Ignore())
                .ForMember(dest => dest.DataGroupCode, opt => opt.Ignore());

            CreateMap<DataCoreDto, CreateUpdateDataCoreDto>(); // For prepopulating edit form

            CreateMap<DataCore, DataCoreLookupDto>(); // For flat lookup lists

            CreateMap<DataCore, DataCoreExcelDto>() // If Excel Export is implemented
                .ForMember(dest => dest.StatusText, opt => opt.Ignore()) // Handled by MappingAction or AppService
                .ForMember(dest => dest.DataGroupCode, opt => opt.Ignore()) // Handled by AppService
                .ForMember(dest => dest.DataGroupName, opt => opt.Ignore()); // Handled by AppService
                // .AfterMap<DataCoreToExcelMappingAction>(); // Apply action if used

            // --- Shared/Lookup Mappings (ensure DataGroup profile exists) ---
            // CreateMap<DataGroup, DataGroupLookupDto>(); // Should exist in DataGroup profile

            // No direct mapping from CreateUpdateDataCoreDto to DataCore entity
            // Create/Update operations use DTO data with DataCoreManager
        }
    }
    ```

## 2. AppService Implementation (`DataCoreAppService`)

-   **Vị trí:** Tạo file `src/Aqt.CoreFW.Application/DataCores/DataCoreAppService.cs`
-   **Nội dung:**
    ```csharp
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Linq.Dynamic.Core; // Required for dynamic sorting
    using System.Threading.Tasks;
    using Aqt.CoreFW.Application.Contracts.DataCores; // Contracts namespace
    using Aqt.CoreFW.Application.Contracts.DataCores.Dtos; // DTOs namespace
    using Aqt.CoreFW.Application.Contracts.Shared.Lookups; // Lookup DTO namespace
    using Aqt.CoreFW.Shared.Services; // IAbpExcelExportHelper namespace
    using Aqt.CoreFW.Domain.DataCores; // Domain Service and Repository Interface namespace
    using Aqt.CoreFW.Domain.DataCores.Entities; // Entity namespace
    using Aqt.CoreFW.Domain.DataGroups; // IDataGroupRepository
    using Aqt.CoreFW.Domain.DataGroups.Entities;
    using Aqt.CoreFW.Localization; // Resource namespace
    using Aqt.CoreFW.Permissions; // Permissions namespace
    using Aqt.CoreFW.DataCores; // Enum namespace from Domain.Shared
    using Microsoft.AspNetCore.Authorization;
    using Microsoft.Extensions.Localization;
    using Volo.Abp;
    using Volo.Abp.Application.Dtos;
    using Volo.Abp.Application.Services;
    using Volo.Abp.Content; // For IRemoteStreamContent
    using Volo.Abp.Domain.Repositories;
    using Volo.Abp.ObjectMapping; // For ObjectMapper

    namespace Aqt.CoreFW.Application.DataCores; // Application Service namespace

    [Authorize(CoreFWPermissions.DataCores.Default)] // Default policy for read
    public class DataCoreAppService :
        CrudAppService<
            DataCore,                  // Entity
            DataCoreDto,               // DTO Read
            Guid,                      // Primary Key
            GetDataCoresInput,         // DTO for GetList input
            CreateUpdateDataCoreDto>,  // DTO for Create/Update input
        IDataCoreAppService            // Implement the contract interface
    {
        private readonly IDataCoreRepository _dataCoreRepository;
        private readonly DataCoreManager _dataCoreManager;
        private readonly IRepository<DataGroup, Guid> _dataGroupRepository; // Basic repo for DataGroup lookup
        private readonly IStringLocalizer<CoreFWResource> _localizer;
        private readonly IAbpExcelExportHelper _excelExportHelper; // Optional: For Excel export

        // Constructor injection
        public DataCoreAppService(
            IDataCoreRepository dataCoreRepository, // Use specific repo for advanced queries
            DataCoreManager dataCoreManager,
            IRepository<DataGroup, Guid> dataGroupRepository, // Inject basic repo
            IStringLocalizer<CoreFWResource> localizer,
            IAbpExcelExportHelper excelExportHelper) // Inject optional helper
            : base(dataCoreRepository) // Pass specific repo to base
        {
            _dataCoreRepository = dataCoreRepository;
            _dataCoreManager = dataCoreManager;
            _dataGroupRepository = dataGroupRepository;
            _localizer = localizer;
            _excelExportHelper = excelExportHelper;

            // Set permission policies
            GetPolicyName = CoreFWPermissions.DataCores.Default;
            GetListPolicyName = CoreFWPermissions.DataCores.Default;
            CreatePolicyName = CoreFWPermissions.DataCores.Create;
            UpdatePolicyName = CoreFWPermissions.DataCores.Update;
            DeletePolicyName = CoreFWPermissions.DataCores.Delete;
        }

        // --- Overridden CRUD Methods ---

        [Authorize(CoreFWPermissions.DataCores.Create)]
        public override async Task<DataCoreDto> CreateAsync(CreateUpdateDataCoreDto input)
        {
            // Use DataCoreManager to create, handling code uniqueness and DataGroup validation
            var entity = await _dataCoreManager.CreateAsync(
                input.Code,
                input.Name,
                input.DataGroupId, // Manager validates this
                input.Order,
                input.Description,
                input.Status
            );

            await _dataCoreRepository.InsertAsync(entity, autoSave: true);
            return await MapToDtoWithDataGroupInfoAsync(entity); // Map with DataGroup info
        }

        [Authorize(CoreFWPermissions.DataCores.Update)]
        public override async Task<DataCoreDto> UpdateAsync(Guid id, CreateUpdateDataCoreDto input)
        {
            var entity = await _dataCoreRepository.GetAsync(id); // Get entity

            // Check for immutable Code change attempt
            if (!string.Equals(entity.Code, input.Code, StringComparison.OrdinalIgnoreCase))
            {
                // For simplicity, forbid Code change.
                // TODO: Localize this exception message
                throw new UserFriendlyException("Changing the DataCore Code is not allowed.");
            }

            // Use manager to handle potential DataGroup change and other updates
            entity = await _dataCoreManager.UpdateAsync(
                entity,
                input.Name,
                input.DataGroupId, // Manager validates if changed
                input.Order,
                input.Description,
                input.Status
            );

            await _dataCoreRepository.UpdateAsync(entity, autoSave: true);
            return await MapToDtoWithDataGroupInfoAsync(entity); // Map with DataGroup info
        }

        // Override GetAsync to include DataGroup Info
        public override async Task<DataCoreDto> GetAsync(Guid id)
        {
            var entity = await _dataCoreRepository.GetAsync(id);
            return await MapToDtoWithDataGroupInfoAsync(entity);
        }

        // Override GetListAsync to include DataGroup Info and handle filtering
        public override async Task<PagedResultDto<DataCoreDto>> GetListAsync(GetDataCoresInput input)
        {
            // 1. Get count
            var totalCount = await _dataCoreRepository.GetCountAsync(
                filterText: input.Filter,
                code: null, // Use filterText for combined search
                name: null, // Use filterText for combined search
                status: input.Status,
                dataGroupId: input.DataGroupId
            );

            // 2. Get list
            var entities = await _dataCoreRepository.GetListAsync(
                filterText: input.Filter,
                code: null,
                name: null,
                status: input.Status,
                dataGroupId: input.DataGroupId,
                sorting: input.Sorting ?? "Order ASC, Name ASC", // Default sort order
                maxResultCount: input.MaxResultCount,
                skipCount: input.SkipCount
            );

            // 3. Fetch related DataGroup data efficiently
            var dataGroupIds = entities.Select(e => e.DataGroupId).Distinct().ToList();
            var dataGroups = new Dictionary<Guid, DataGroup>();
            if (dataGroupIds.Any())
            {
                dataGroups = (await _dataGroupRepository.GetListAsync(dg => dataGroupIds.Contains(dg.Id)))
                                .ToDictionary(dg => dg.Id);
            }

            // 4. Map to DTOs and populate DataGroup info
            var dtos = entities.Select(entity =>
            {
                var dto = ObjectMapper.Map<DataCore, DataCoreDto>(entity);
                if (dataGroups.TryGetValue(entity.DataGroupId, out var dataGroup))
                {
                    dto.DataGroupName = dataGroup.Name;
                    dto.DataGroupCode = dataGroup.Code;
                }
                return dto;
            }).ToList();

            return new PagedResultDto<DataCoreDto>(totalCount, dtos);
        }

        // --- Custom AppService Methods ---

        [Authorize(CoreFWPermissions.DataCores.Default)] // Same policy as GetList
        public async Task<ListResultDto<DataCoreLookupDto>> GetLookupByDataGroupAsync(Guid dataGroupId)
        {
            // Use the specific repository method added in Domain plan
            var dataCores = await _dataCoreRepository.GetListByDataGroupIdAsync(
                dataGroupId: dataGroupId,
                onlyActive: true // Typically lookups only need active items
            );

            var dtos = ObjectMapper.Map<List<DataCore>, List<DataCoreLookupDto>>(dataCores);
            return new ListResultDto<DataCoreLookupDto>(dtos);
        }

        // Optional: Implement Excel Export
        [Authorize(CoreFWPermissions.DataCores.Export)]
        public async Task<IRemoteStreamContent> GetListAsExcelAsync(GetDataCoresInput input)
        {
            // 1. Get filtered list (no pagination for export)
            var entities = await _dataCoreRepository.GetListAsync(
                filterText: input.Filter,
                code: null,
                name: null,
                status: input.Status,
                dataGroupId: input.DataGroupId,
                sorting: input.Sorting ?? "Order ASC, Name ASC",
                maxResultCount: int.MaxValue, // Get all matching for export
                skipCount: 0
            );

            // 2. Fetch related DataGroup data efficiently
            var dataGroupIds = entities.Select(e => e.DataGroupId).Distinct().ToList();
            var dataGroups = new Dictionary<Guid, DataGroup>();
            if (dataGroupIds.Any())
            {
                dataGroups = (await _dataGroupRepository.GetListAsync(dg => dataGroupIds.Contains(dg.Id)))
                                .ToDictionary(dg => dg.Id);
            }

            // 3. Map to Excel DTOs and populate related info
            var excelDtos = entities.Select(entity =>
            {
                var dto = ObjectMapper.Map<DataCore, DataCoreExcelDto>(entity);
                // Manually populate DataGroup info and StatusText here
                dto.StatusText = _localizer[$"Enum:DataCoreStatus.{(int)entity.Status}"];
                if (dataGroups.TryGetValue(entity.DataGroupId, out var dataGroup))
                {
                    dto.DataGroupName = dataGroup.Name;
                    dto.DataGroupCode = dataGroup.Code;
                }
                return dto;
            }).ToList();

            // 4. Use helper to generate Excel file
            var fileContent = await _excelExportHelper.ExportToExcelAsync(excelDtos, "DataCores");
            return fileContent;
        }

        // --- Helper Methods ---

        /// <summary>
        /// Maps a DataCore entity to DataCoreDto and populates DataGroup info.
        /// </summary>
        private async Task<DataCoreDto> MapToDtoWithDataGroupInfoAsync(DataCore entity)
        {
            var dto = ObjectMapper.Map<DataCore, DataCoreDto>(entity);
            // Fetch DataGroup info
            var dataGroup = await _dataGroupRepository.FindAsync(entity.DataGroupId);
            if (dataGroup != null)
            {
                dto.DataGroupName = dataGroup.Name;
                dto.DataGroupCode = dataGroup.Code;
            }
            return dto;
        }
    } 
    ```

## 3. Cập nhật `CoreFWApplicationModule.cs`

-   **Vị trí:** `src/Aqt.CoreFW.Application/CoreFWApplicationModule.cs`
-   **Hành động:** Đảm bảo rằng project `Aqt.CoreFW.Application` có tham chiếu đến `Aqt.CoreFW.Application.Contracts`. Cập nhật phương thức `ConfigureServices` để đăng ký AutoMapper profile.
-   **Nội dung cần thêm/cập nhật trong `ConfigureServices`:**
    ```csharp
    Configure<AbpAutoMapperOptions>(options =>
    {
        // Add all profiles in this assembly
        // options.AddMaps<CoreFWApplicationModule>();

        // Hoặc thêm từng profile cụ thể
        options.AddProfile<DataCoreApplicationAutoMapperProfile>(validate: true); // Thêm profile của DataCore
        // options.AddProfile<DataGroupApplicationAutoMapperProfile>(validate: true); // Đảm bảo profile DataGroup cũng được thêm
        // ... các profile khác ...
    });
    ```

## 4. Lưu ý

*   **Dependency Injection:** `DataCoreAppService` inject `IDataCoreRepository`, `DataCoreManager`, `IRepository<DataGroup, Guid>`, `IStringLocalizer`, và (tùy chọn) `IAbpExcelExportHelper`.
*   **Permissions:** Các phương thức CRUD và phương thức tùy chỉnh được bảo vệ bằng các permission đã định nghĩa trong `CoreFWPermissions`.
*   **Mapping:** AutoMapper được sử dụng để chuyển đổi giữa Entity và DTO. Các thông tin liên quan (DataGroupName, DataGroupCode) được load và gán trong AppService để tránh N+1 query trong tầng Repository hoặc Mapping Actions.
*   **Domain Service Usage:** Logic tạo (`CreateAsync`) và cập nhật (`UpdateAsync`) phức tạp được ủy thác cho `DataCoreManager` để đảm bảo tuân thủ quy tắc nghiệp vụ.
*   **Repository Usage:** AppService sử dụng `IDataCoreRepository` cho các truy vấn phức tạp (lọc, sắp xếp, lookup) và `IRepository<DataGroup, Guid>` để lấy thông tin DataGroup liên quan.
*   **Error Handling:** Sử dụng `UserFriendlyException` hoặc `BusinessException` (từ Domain Service) để thông báo lỗi cho người dùng.
*   **Excel Export:** Việc triển khai `GetListAsExcelAsync` là tùy chọn. Nó yêu cầu một service helper (`IAbpExcelExportHelper`) và thư viện MiniExcel. Logic load dữ liệu tương tự `GetListAsync` nhưng không phân trang và mapping sang `DataCoreExcelDto`.
*   **Lookup Optimization:** `GetLookupByDataGroupAsync` sử dụng phương thức `GetListByDataGroupIdAsync` đã thêm vào `IDataCoreRepository` để tối ưu việc lấy dữ liệu lookup.

</rewritten_file> 