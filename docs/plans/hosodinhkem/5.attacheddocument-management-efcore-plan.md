# Kế hoạch chi tiết: Tầng EntityFrameworkCore (`Aqt.CoreFW.EntityFrameworkCore`) - Quản lý Attached Document (AttachedDocument Management)

Phần này mô tả các thành phần cần tạo hoặc cập nhật trong tầng `Aqt.CoreFW.EntityFrameworkCore` cho module Quản lý Attached Document.

## 1. DbContext

-   **Vị trí:** Cập nhật file `src/Aqt.CoreFW.EntityFrameworkCore/EntityFrameworkCore/CoreFWDbContext.cs`
-   **Nội dung cần thêm:**
    ```csharp
    using Aqt.CoreFW.Domain.AttachedDocuments.Entities; // Thêm using cho AttachedDocument Entity
    using Microsoft.EntityFrameworkCore;
    using System.Reflection;
    // ... other usings ...

    public class CoreFWDbContext : AbpDbContext<CoreFWDbContext>, /* ... các interface khác ... */
    {
        // ... các DbSet khác (Procedure, DataGroup, DataCore, Province, etc.) ...
        public DbSet<AttachedDocument> AttachedDocuments { get; set; } // Thêm DbSet cho AttachedDocument


        public CoreFWDbContext(DbContextOptions<CoreFWDbContext> options)
            : base(options)
        {
        }

        protected override void OnModelCreating(ModelBuilder builder)
        {
            base.OnModelCreating(builder);

            // Cấu hình các module khác của ABP...
            // ...

            // Áp dụng tất cả cấu hình entity trong assembly này
            builder.ApplyConfigurationsFromAssembly(Assembly.GetExecutingAssembly());
        }
    }
    ```

## 2. Entity Configuration (`AttachedDocumentConfiguration.cs`)

-   **Vị trí:** Tạo thư mục `src/Aqt.CoreFW.EntityFrameworkCore/EntityTypeConfigurations/AttachedDocuments` (Tạo thư mục nếu chưa có)
-   **Tệp:** Tạo file `AttachedDocumentConfiguration.cs`
-   **Nội dung:**
    ```csharp
    using Aqt.CoreFW.Domain.AttachedDocuments.Entities; // AttachedDocument Entity
    using Aqt.CoreFW.Domain.Procedures.Entities; // Procedure Entity for FK relation (Giả định)
    using Aqt.CoreFW.Domain.Shared; // Namespace chứa CoreFWConsts
    using Aqt.CoreFW.AttachedDocuments; // Namespace chứa AttachedDocumentConsts và AttachedDocumentStatus enum
    using Microsoft.EntityFrameworkCore;
    using Microsoft.EntityFrameworkCore.Metadata.Builders;
    using Volo.Abp.EntityFrameworkCore.Modeling;

    namespace Aqt.CoreFW.EntityFrameworkCore.EntityTypeConfigurations.AttachedDocuments; // Namespace Configuration

    /// <summary>
    /// Configures the database mapping for the <see cref="AttachedDocument"/> entity.
    /// </summary>
    public class AttachedDocumentConfiguration : IEntityTypeConfiguration<AttachedDocument>
    {
        public void Configure(EntityTypeBuilder<AttachedDocument> builder)
        {
            // Sử dụng DbTablePrefix và DbSchema từ CoreFWConsts
            builder.ToTable(CoreFWConsts.DbTablePrefix + "AttachedDocuments", CoreFWConsts.DbSchema);

            builder.ConfigureByConvention(); // Áp dụng các quy ước chuẩn của ABP

            builder.HasKey(x => x.Id);

            // --- Property Configurations ---
            builder.Property(x => x.Code)
                .IsRequired()
                .HasMaxLength(AttachedDocumentConsts.MaxCodeLength)
                .HasColumnName(nameof(AttachedDocument.Code));

            builder.Property(x => x.Name)
                .IsRequired()
                .HasMaxLength(AttachedDocumentConsts.MaxNameLength)
                .HasColumnName(nameof(AttachedDocument.Name));

            builder.Property(x => x.Status)
                .IsRequired()
                .HasColumnName(nameof(AttachedDocument.Status))
                .HasConversion<byte>(); // Map enum sang byte

            builder.Property(x => x.Order)
                .IsRequired()
                .HasColumnName(nameof(AttachedDocument.Order));

            builder.Property(x => x.Description)
                .HasMaxLength(AttachedDocumentConsts.MaxDescriptionLength)
                .HasColumnName(nameof(AttachedDocument.Description));

            // ProcedureId là Guid bắt buộc
            builder.Property(x => x.ProcedureId)
                .IsRequired()
                .HasColumnName(nameof(AttachedDocument.ProcedureId));

            // --- Foreign Keys ---
            builder.HasOne<Procedure>() // Không cần chỉ định navigation property 'Procedure' nếu không có trong Entity (Giả định Entity tên Procedure)
                   .WithMany() // Một Procedure có thể có nhiều AttachedDocument
                   .HasForeignKey(x => x.ProcedureId)
                   .IsRequired() // Đảm bảo FK là bắt buộc
                   .OnDelete(DeleteBehavior.Restrict); // Quan trọng: Ngăn chặn việc xóa Procedure nếu còn AttachedDocument tham chiếu

            // --- Indexes ---

            // Index cho Code (Unique theo ProcedureId)
            builder.HasIndex(x => new { x.ProcedureId, x.Code })
                   .IsUnique() // Đảm bảo Code là duy nhất trong phạm vi ProcedureId
                   .HasDatabaseName($"IX_{CoreFWConsts.DbTablePrefix}AttachedDocuments_ProcedureId_Code");

            builder.HasIndex(x => x.Name)
                   .HasDatabaseName($"IX_{CoreFWConsts.DbTablePrefix}AttachedDocuments_Name");

            builder.HasIndex(x => x.Status)
                   .HasDatabaseName($"IX_{CoreFWConsts.DbTablePrefix}AttachedDocuments_Status");

            // Index trên ProcedureId (đã có trong index kết hợp bên trên, nhưng thêm riêng cũng không sao)
            builder.HasIndex(x => x.ProcedureId)
                   .HasDatabaseName($"IX_{CoreFWConsts.DbTablePrefix}AttachedDocuments_ProcedureId");

            // Index kết hợp cho sắp xếp/lọc phổ biến trong cùng thủ tục
            builder.HasIndex(x => new { x.ProcedureId, x.Status, x.Order, x.Name })
                  .HasDatabaseName($"IX_{CoreFWConsts.DbTablePrefix}AttachedDocuments_ProcedureId_Status_Order_Name");
        }
    }
    ```

## 3. Repository Implementation (`AttachedDocumentRepository.cs`)

-   **Vị trí:** Tạo thư mục `src/Aqt.CoreFW.EntityFrameworkCore/Repositories/AttachedDocuments` (Tạo thư mục nếu chưa có)
-   **Tệp:** Tạo file `AttachedDocumentRepository.cs` bên trong thư mục trên
-   **Nội dung:**
    ```csharp
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Linq.Dynamic.Core;
    using System.Threading;
    using System.Threading.Tasks;
    using Aqt.CoreFW.Domain.AttachedDocuments; // IAttachedDocumentRepository
    using Aqt.CoreFW.Domain.AttachedDocuments.Entities; // AttachedDocument Entity
    using Aqt.CoreFW.EntityFrameworkCore; // CoreFWDbContext, EfCoreRepository
    using Aqt.CoreFW.AttachedDocuments; // AttachedDocumentStatus enum
    using JetBrains.Annotations;
    using Microsoft.EntityFrameworkCore;
    using Volo.Abp.Domain.Repositories.EntityFrameworkCore;
    using Volo.Abp.EntityFrameworkCore;

    namespace Aqt.CoreFW.EntityFrameworkCore.Repositories.AttachedDocuments;

    public class AttachedDocumentRepository :
        EfCoreRepository<CoreFWDbContext, AttachedDocument, Guid>,
        IAttachedDocumentRepository
    {
        public AttachedDocumentRepository(IDbContextProvider<CoreFWDbContext> dbContextProvider)
            : base(dbContextProvider)
        {
        }

        // Implementation requires ProcedureId because Code is unique per procedure
        public async Task<AttachedDocument?> FindByCodeAsync(
            [NotNull] string code,
            Guid procedureId,
            bool includeDetails = false, // Typically false if no navigation props needed
            CancellationToken cancellationToken = default)
        {
            var dbSet = await GetDbSetAsync();
            var query = dbSet.AsNoTracking(); // Use AsNoTracking for read-only queries

            // If includeDetails is true and navigation properties exist, add .Include() here
            // query = includeDetails ? query.Include(ad => ad.Procedure) : query; // Giả định navigation property

            return await query.FirstOrDefaultAsync(
                ad => ad.ProcedureId == procedureId && ad.Code == code,
                GetCancellationToken(cancellationToken));
        }

        // Implementation requires ProcedureId
        public async Task<bool> CodeExistsAsync(
            [NotNull] string code,
            Guid procedureId,
            Guid? excludeId = null,
            CancellationToken cancellationToken = default)
        {
            var dbSet = await GetDbSetAsync();
            var query = dbSet.AsNoTracking()
                             .Where(ad => ad.ProcedureId == procedureId && ad.Code == code);

            if (excludeId.HasValue)
            {
                query = query.Where(ad => ad.Id != excludeId.Value);
            }

            return await query.AnyAsync(GetCancellationToken(cancellationToken));
        }

        public async Task<List<AttachedDocument>> GetListAsync(
            string? filterText = null,
            string? code = null,
            string? name = null,
            AttachedDocumentStatus? status = null,
            Guid? procedureId = null,
            string? sorting = null,
            int maxResultCount = int.MaxValue,
            int skipCount = 0,
            CancellationToken cancellationToken = default)
        {
            var query = await GetListQueryInternalAsync(filterText, code, name, status, procedureId);

            query = query.OrderBy(sorting.IsNullOrWhiteSpace() ?
                $"{nameof(AttachedDocument.Order)} asc, {nameof(AttachedDocument.Name)} asc" // Default sort
                : sorting);

            return await query.PageBy(skipCount, maxResultCount)
                              .ToListAsync(GetCancellationToken(cancellationToken));
        }

        public async Task<long> GetCountAsync(
            string? filterText = null,
            string? code = null,
            string? name = null,
            AttachedDocumentStatus? status = null,
            Guid? procedureId = null,
            CancellationToken cancellationToken = default)
        {
            var query = await GetListQueryInternalAsync(filterText, code, name, status, procedureId);
            return await query.LongCountAsync(GetCancellationToken(cancellationToken));
        }

        public async Task<List<AttachedDocument>> GetListByProcedureIdAsync(
            Guid procedureId,
            bool onlyActive = true,
            string? sorting = null, // Default handled below
            CancellationToken cancellationToken = default)
        {
            var dbSet = await GetDbSetAsync();
            var query = dbSet.AsNoTracking().Where(ad => ad.ProcedureId == procedureId);

            if (onlyActive)
            {
                query = query.Where(ad => ad.Status == AttachedDocumentStatus.Active);
            }

            query = query.OrderBy(sorting.IsNullOrWhiteSpace() ?
                 $"{nameof(AttachedDocument.Order)} asc, {nameof(AttachedDocument.Name)} asc" // Sensible default for lookups
                 : sorting);

            // No pagination for typical lookup lists
            return await query.ToListAsync(GetCancellationToken(cancellationToken));
        }

        // --- Private Helper Method ---

        private async Task<IQueryable<AttachedDocument>> GetListQueryInternalAsync(
            string? filterText = null,
            string? code = null,
            string? name = null,
            AttachedDocumentStatus? status = null,
            Guid? procedureId = null)
        {
            var dbSet = await GetDbSetAsync();
            return dbSet.AsNoTracking()
                // Combined filter for Code or Name
                .WhereIf(!filterText.IsNullOrWhiteSpace(), ad =>
                    (ad.Code != null && ad.Code.Contains(filterText!)) ||
                    (ad.Name != null && ad.Name.Contains(filterText!)))
                // Specific filters
                .WhereIf(!code.IsNullOrWhiteSpace(), ad => ad.Code == code)
                .WhereIf(!name.IsNullOrWhiteSpace(), ad => ad.Name != null && ad.Name.Contains(name))
                .WhereIf(status.HasValue, ad => ad.Status == status!.Value)
                .WhereIf(procedureId.HasValue, ad => ad.ProcedureId == procedureId!.Value);
        }
    }
    ```

## 4. Cập nhật `CoreFWDbContextModelCreatingExtensions.cs` (Không bắt buộc nếu dùng `ApplyConfigurationsFromAssembly`)

-   **Vị trí:** `src/Aqt.CoreFW.EntityFrameworkCore/EntityFrameworkCore/CoreFWDbContextModelCreatingExtensions.cs`
-   **Hành động:** Nếu bạn **không** sử dụng `builder.ApplyConfigurationsFromAssembly(Assembly.GetExecutingAssembly());` trong `CoreFWDbContext.OnModelCreating`, bạn cần gọi thủ công phương thức cấu hình cho `AttachedDocument` tại đây.
    ```csharp
    public static void ConfigureCoreFW(this ModelBuilder builder)
    {
        Check.NotNull(builder, nameof(builder));

        // ... Cấu hình cho các entity khác (Province, District, Commune, Rank, DataGroup, DataCore, Procedure) ...

        // Cấu hình cho AttachedDocument
        builder.ApplyConfiguration(new Aqt.CoreFW.EntityFrameworkCore.EntityTypeConfigurations.AttachedDocuments.AttachedDocumentConfiguration());

        // ... các cấu hình khác ...
    }
    ```
    **Khuyến nghị:** Sử dụng `ApplyConfigurationsFromAssembly` để tự động áp dụng tất cả cấu hình.

## 5. Database Migrations

-   **Hành động:**
    1.  **Thêm Migration:** Mở Package Manager Console (PMC) hoặc terminal, chọn project `Aqt.CoreFW.EntityFrameworkCore` làm project mặc định.
        ```bash
        dotnet ef migrations add Added_AttachedDocument_Module
        ```
        *(Sử dụng tên migration mô tả, ví dụ: `Added_AttachedDocument_Module`, `Added_AttachedDocuments_Table`)*
    2.  **Kiểm tra Migration:** Mở file migration mới được tạo trong thư mục `Migrations` của project `Aqt.CoreFW.EntityFrameworkCore` để xem lại các thay đổi SQL được tạo ra (tạo bảng `AttachedDocuments`, thêm cột, khóa ngoại, **index unique kết hợp trên ProcedureId và Code**).
    3.  **Cập nhật Database:**
        ```bash
        dotnet ef database update
        ```

## 6. Lưu ý

*   **Namespace:** Đảm bảo các namespace là chính xác cho Entity, Enum, Constants, Configuration, Repository và DbContext.
*   **Code Uniqueness:** Cấu hình và logic Repository đã được điều chỉnh để đảm bảo `AttachedDocument.Code` là **duy nhất trong phạm vi `ProcedureId`**. Điều này thể hiện qua `HasIndex(...).IsUnique()` kết hợp và các phương thức `FindByCodeAsync`, `CodeExistsAsync` yêu cầu `procedureId`.
*   **Foreign Key Constraint:** Đã cấu hình `OnDelete(DeleteBehavior.Restrict)` cho khóa ngoại `ProcedureId` để ngăn xóa `Procedure` (giả định) nếu còn `AttachedDocument` liên quan.
*   **Indexes:** Đã thêm các index cần thiết, bao gồm index unique kết hợp và các index khác để tối ưu lọc/sắp xếp.
*   **Repository Implementation:** Repository triển khai các phương thức trong `IAttachedDocumentRepository`, sử dụng LINQ và `IQueryable`. Logic đã được điều chỉnh để phù hợp với ràng buộc unique theo `ProcedureId`.
*   **Raw SQL:** Tránh sử dụng Raw SQL.
*   **Migrations:** Luôn tạo và kiểm tra migration cẩn thận, đặc biệt là cấu trúc index unique, trước khi cập nhật database.
*   **Giả định về Procedure:** Kế hoạch này giả định sự tồn tại của Entity `Procedure` trong namespace `Aqt.CoreFW.Domain.Procedures.Entities`. Cần điều chỉnh lại nếu tên hoặc namespace thực tế khác.
