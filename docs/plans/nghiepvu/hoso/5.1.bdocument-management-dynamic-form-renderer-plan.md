# Kế hoạch 5.1: Tạo Partial View Render Form Động (`_DynamicFormRenderer.cshtml`)

**Mục đích:** Tạo một Partial View Razor (`.cshtml`) trong tầng Web có khả năng nhận vào một chuỗi JSON định nghĩa cấu trúc form (`FormDefinition`) và một chuỗi JSON chứa dữ liệu ban đầu (`FormData`), sau đó tự động sinh ra các thẻ HTML input tương ứng. Component này được thiết kế để tái sử dụng, hiển thị các form động dựa trên cấu hình JSON, điển hình là phần "Tờ khai" trong module Quản lý Hồ sơ (BDocument).

## 1. Yêu cầu chức năng

-   **Nhận đầu vào:** Partial View cần nhận được Model là `Aqt.CoreFW.Web.Pages.BDocuments.ViewModels.BDocumentDataViewModel` (hoặc một ViewModel/Model tương tự chứa hai thuộc tính chuỗi sau):
    -   `FormDefinition`: Chuỗi JSON mô tả các trường của form (tên, nhãn, kiểu dữ liệu, bắt buộc, lựa chọn, v.v.). Cấu trúc JSON dự kiến có một mảng `fields`.
    -   `FormData`: Chuỗi JSON chứa dữ liệu ban đầu cho form (dạng key-value, với key là tên trường). Có thể là null hoặc chuỗi JSON rỗng nếu là form mới.
-   **Phân tích JSON:** Sử dụng C# và `System.Text.Json` (hoặc `System.Text.Json.Nodes`) để parse chuỗi `FormDefinition` và `FormData`. Cần xử lý các trường hợp JSON không hợp lệ một cách an toàn.
-   **Sinh HTML động:**
    -   Lặp qua mảng `fields` trong `FormDefinition`.
    -   Với mỗi field, dựa vào thuộc tính `type` (ví dụ: "text", "textarea", "select", "date", "checkbox", "number", "email", "tel", "url"), sinh ra thẻ HTML tương ứng (`<input>`, `<select>`, `<textarea>`). **Không** sử dụng Tag Helper như `<abp-input>` vì chúng bind vào thuộc tính cố định của ViewModel.
    -   Thiết lập các attribute HTML cần thiết:
        -   `name`: Theo quy ước `DeclarationFields[ten_truong]` (hoặc một tiền tố có thể cấu hình nếu cần) để JavaScript dễ dàng thu thập.
        -   `id`: Duy nhất cho mỗi control để liên kết với `<label>` (ví dụ: `declaration_{fieldName}`).
        -   `class`: Sử dụng các class của Bootstrap 5 (`form-control`, `form-select`, `form-check-input`, `form-control-sm`, etc.).
        -   `required`: Nếu field có `required: true` trong JSON.
        -   `placeholder`: Lấy từ thuộc tính `placeholder` trong JSON (và nên được localize).
        -   `value` / `checked`: Thiết lập dựa trên dữ liệu parse từ `FormData`.
        -   `data-field-name`: Gán tên gốc của trường (`field.name`) để JavaScript tham chiếu.
    -   Hỗ trợ các loại control đặc biệt:
        -   `select`: Sinh các thẻ `<option>` dựa trên mảng `options` trong JSON (mỗi option có `value` và `text`).
        -   `checkbox`: Sinh `<input type="checkbox">` và xử lý trạng thái `checked`. Cần có hidden input đi kèm để gửi giá trị `false` nếu không được check.
        -   `radio`: (Nếu cần) Sinh các `<input type="radio">` với cùng `name` nhưng `value` khác nhau.
-   **Tạo Label:** Sinh thẻ `<label>` cho mỗi trường, lấy nội dung từ thuộc tính `label` trong `FormDefinition`. Hiển thị dấu `*` (ví dụ: `<span class='text-danger ms-1'>*</span>`) nếu `required: true`.
-   **Hỗ trợ Localization:** Nội dung của `label`, `placeholder`, và `text` của `<option>` nên được coi là *key localization*. Partial View phải sử dụng `IHtmlLocalizer<CoreFWResource>` (hoặc resource tương ứng) để dịch các key này trước khi hiển thị.
-   **Xử lý lỗi:** Nếu `FormDefinition` không hợp lệ hoặc không thể parse, hiển thị một thông báo lỗi rõ ràng (ví dụ: dùng `abp-alert`). Tương tự nếu `FormData` không parse được.
-   **Layout:** Sắp xếp các trường một cách hợp lý, ví dụ sử dụng `<abp-row>` và `<abp-column size-md="_6">` (hoặc tương tự) để tạo layout 2 cột cơ bản. Có thể xem xét thêm thuộc tính `layoutHint` trong JSON để điều khiển layout phức tạp hơn trong tương lai.
-   **Mô tả (Description):** Hiển thị nội dung `description` của field (nếu có trong JSON) dưới dạng text hỗ trợ (`form-text`).

## 2. Đầu vào (Model)

Partial View sẽ nhận Model là `Aqt.CoreFW.Web.Pages.BDocuments.ViewModels.BDocumentDataViewModel`.

```csharp
// Namespace: Aqt.CoreFW.Web.Pages.BDocuments.ViewModels
public class BDocumentDataViewModel
{
    // ... các thuộc tính khác của component data (ID, ProcedureComponentId, FileId...)
    public string? FormDefinition { get; set; } // JSON định nghĩa form
    public string? FormData { get; set; } // JSON dữ liệu ban đầu (key-value)
    // ...
}
```

## 3. Vị trí file

-   **Khuyến nghị:** `src/Aqt.CoreFW.Web/Pages/Shared/Components/DynamicFormRenderer/_DynamicFormRenderer.cshtml` (Để nhấn mạnh tính tái sử dụng)
-   Hoặc: `src/Aqt.CoreFW.Web/Pages/BDocuments/_DynamicFormRenderer.cshtml` (Nếu chỉ dùng trong BDocuments)

## 4. Mã nguồn Razor (Ví dụ tham khảo)

```cshtml
@* Nội dung file: _DynamicFormRenderer.cshtml *@
@using System.Text.Json
@using System.Text.Json.Nodes
@using Microsoft.AspNetCore.Mvc.Localization
@using Aqt.CoreFW.Localization
@using Aqt.CoreFW.Web.Pages.BDocuments.ViewModels // Hoặc namespace chứa ViewModel đầu vào
@model BDocumentDataViewModel // Hoặc ViewModel tương đương
@inject IHtmlLocalizer<CoreFWResource> L

@{
    // --- Parse FormDefinition JSON ---
    JsonNode? formDefinitionNode = null;
    bool definitionParseError = false;
    string definitionErrorMessage = string.Empty;
    try
    {
        if (!string.IsNullOrWhiteSpace(Model.FormDefinition))
        {
            formDefinitionNode = JsonNode.Parse(Model.FormDefinition);
        }
    }
    catch (JsonException ex)
    {
        definitionParseError = true;
        definitionErrorMessage = $"Error parsing FormDefinition: {ex.Message}";
        // Log lỗi ở đây nếu cần: Logger.LogError(ex, "Error parsing FormDefinition JSON for Component {ComponentId}", Model.ProcedureComponentId);
    }

    // --- Parse FormData JSON ---
    Dictionary<string, JsonNode?> initialData = new();
    try
    {
        if (!string.IsNullOrWhiteSpace(Model.FormData))
        {
             var dataNode = JsonNode.Parse(Model.FormData);
             if(dataNode is JsonObject dataObj)
             {
                  initialData = dataObj.ToDictionary(kv => kv.Key, kv => kv.Value, StringComparer.OrdinalIgnoreCase); // Key không phân biệt hoa thường
             }
        }
    }
    catch (JsonException ex)
    {
         // Có thể chỉ log lỗi, không cần hiển thị ra UI trừ khi debug
         // Logger.LogError(ex, "Error parsing FormData JSON for Component {ComponentId}", Model.ProcedureComponentId);
    }

    // --- Helper lấy giá trị ban đầu ---
    string? GetInitialValueAsString(string? fieldName)
    {
        if (string.IsNullOrEmpty(fieldName) || !initialData.TryGetValue(fieldName, out var node) || node == null)
            return null;
        // Cần xử lý các kiểu dữ liệu khác nhau từ JSON nếu cần (number, boolean...)
        return node.GetValue<string>();
    }
    bool GetInitialValueAsBool(string? fieldName)
    {
        if (string.IsNullOrEmpty(fieldName) || !initialData.TryGetValue(fieldName, out var node) || node == null)
            return false;
        try { return node.GetValue<bool>(); } catch { return false; } // An toàn nếu parse lỗi
    }

}

@if (definitionParseError)
{
    <abp-alert alert-type="Danger">@definitionErrorMessage</abp-alert>
}
else if (formDefinitionNode?["fields"] is JsonArray fields && fields.Count > 0)
{
    <abp-row>
        @* TODO: Cân nhắc logic chia cột dựa trên tổng số field hoặc hint trong JSON *@
        @{ int fieldIndex = 0; }
        @foreach (var fieldNode in fields)
        {
            if (fieldNode is JsonObject field)
            {
                // --- Lấy thuộc tính field từ JSON ---
                var fieldName = field["name"]?.GetValue<string>();
                if (string.IsNullOrWhiteSpace(fieldName)) continue; // Bỏ qua field không có tên

                var fieldLabelKey = field["label"]?.GetValue<string>() ?? fieldName;
                var fieldType = field["type"]?.GetValue<string>()?.ToLowerInvariant() ?? "text";
                var isRequired = field["required"]?.GetValue<bool>() ?? false;
                var placeholderKey = field["placeholder"]?.GetValue<string>();
                var descriptionKey = field["description"]?.GetValue<string>();
                var readonlyFlag = field["readonly"]?.GetValue<bool>() ?? false; // Thêm hỗ trợ readonly

                // --- Lấy giá trị ban đầu ---
                var initialValueStr = GetInitialValueAsString(fieldName);

                // --- Chuẩn bị attribute ---
                var requiredAttr = isRequired ? "required" : null;
                var requiredSpan = isRequired ? Html.Raw("<span class='text-danger ms-1'>*</span>") : Html.Raw("");
                var inputName = $"DeclarationFields[{fieldName}]"; // Quy ước tên cho binding/JS
                var inputId = $"declaration_{fieldName}_{Guid.NewGuid().ToString("N").Substring(0, 8)}"; // Đảm bảo ID duy nhất
                var readonlyAttr = readonlyFlag ? "readonly" : null;
                var disabledAttr = readonlyFlag ? "disabled" : null; // Thường readonly đi với disabled cho select/checkbox

                // --- Render theo cột (ví dụ đơn giản chia 2 cột) ---
                if (fieldIndex % 2 == 0) { @Html.Raw("<abp-column size-md=\"_6\">") }

                <div class="mb-3">
                    <label class="form-label" for="@inputId">@L[fieldLabelKey] @requiredSpan</label>

                    @switch (fieldType)
                    {
                        case "textarea":
                            <textarea class="form-control form-control-sm" name="@inputName" id="@inputId" placeholder="@L[placeholderKey]" required="@requiredAttr" data-field-name="@fieldName" readonly="@readonlyAttr">@initialValueStr</textarea>
                            break;
                        case "select":
                            <select class="form-select form-select-sm" name="@inputName" id="@inputId" required="@requiredAttr" data-field-name="@fieldName" disabled="@disabledAttr">
                                <option value="">@L["Select"]</option>
                                @if (field["options"] is JsonArray options) {
                                    foreach (var optionNode in options) {
                                        if(optionNode is JsonObject option) {
                                            var optValue = option["value"]?.GetValue<string>();
                                            var optTextKey = option["text"]?.GetValue<string>() ?? optValue;
                                            var selected = optValue != null && optValue.Equals(initialValueStr, StringComparison.OrdinalIgnoreCase) ? "selected" : null;
                                            <option value="@optValue" selected="@selected">@L[optTextKey]</option>
                                        }
                                    }
                                }
                            </select>
                            break;
                         case "date":
                            <input type="date" class="form-control form-control-sm" name="@inputName" id="@inputId" required="@requiredAttr" value="@initialValueStr" data-field-name="@fieldName" readonly="@readonlyAttr" />
                            break;
                         case "datetime-local":
                             <input type="datetime-local" class="form-control form-control-sm" name="@inputName" id="@inputId" required="@requiredAttr" value="@initialValueStr" data-field-name="@fieldName" readonly="@readonlyAttr" />
                             break;
                         case "checkbox":
                             var isChecked = GetInitialValueAsBool(fieldName);
                             <div class="form-check">
                                 <input type="checkbox" class="form-check-input" name="@inputName" id="@inputId" value="true" required="@requiredAttr" data-field-name="@fieldName" checked="@isChecked" disabled="@disabledAttr" />
                                 <input type="hidden" name="@inputName" value="false" /> @* Luôn gửi false nếu checkbox không được check *@
                                  @* Label cho checkbox có thể đặt ở đây hoặc dùng label chung ở trên *@
                                 @* <label class="form-check-label" for="@inputId">@L[fieldLabelKey]</label> *@
                             </div>
                             break;
                         case "radio":
                               @if (field["options"] is JsonArray radioOptions) {
                                    <div id="@inputId"> @* Container cho radio group *@
                                    @foreach (var optionNode in radioOptions) {
                                        if(optionNode is JsonObject option) {
                                            var optValue = option["value"]?.GetValue<string>();
                                            var optTextKey = option["text"]?.GetValue<string>() ?? optValue;
                                            var radioId = $"{inputId}_{optValue}";
                                            var selected = optValue != null && optValue.Equals(initialValueStr, StringComparison.OrdinalIgnoreCase) ? "checked" : null;
                                            <div class="form-check form-check-inline">
                                                <input class="form-check-input" type="radio" name="@inputName" id="@radioId" value="@optValue" required="@requiredAttr" data-field-name="@fieldName" checked="@selected" disabled="@disabledAttr">
                                                <label class="form-check-label" for="@radioId">@L[optTextKey]</label>
                                            </div>
                                        }
                                    }
                                    </div>
                                }
                             break;
                         case "number":
                         case "email":
                         case "tel":
                         case "url":
                         case "text":
                         default:
                             <input type="@fieldType" class="form-control form-control-sm" name="@inputName" id="@inputId" placeholder="@L[placeholderKey]" required="@requiredAttr" value="@initialValueStr" data-field-name="@fieldName" readonly="@readonlyAttr"/>
                             break;
                    }
                    @if (!string.IsNullOrEmpty(descriptionKey)) {
                        <div class="form-text small text-muted">@L[descriptionKey]</div>
                    }
                </div>

                @if (fieldIndex % 2 != 0 || fieldIndex == fields.Count - 1) { @Html.Raw("</abp-column>") }
                fieldIndex++;
            }
        }
    </abp-row>
}
else if (!definitionParseError)
{
    <abp-alert alert-type="Warning">@L["NoFieldsDefinedInFormDefinition"]</abp-alert>
}
```

## 5. Hướng dẫn sử dụng

Component này được thiết kế để gọi từ một Razor Page hoặc View khác sử dụng `Html.PartialAsync`.

**Yêu cầu phía nơi gọi (Ví dụ: `CreateModal.cshtml.cs`):**

1.  **Lấy `FormDefinition`:** Trong phương thức `OnGetAsync` (hoặc tương đương), cần lấy chuỗi JSON `FormDefinition` từ nguồn dữ liệu (ví dụ: từ `ProcedureComponentDto`).
2.  **Lấy `FormData` (Nếu có):** Nếu là trường hợp xem/sửa, cần lấy chuỗi JSON `FormData` đã lưu (ví dụ: từ `BDocumentDataDto`).
3.  **Chuẩn bị Model:** Tạo một instance của `BDocumentDataViewModel` (hoặc ViewModel tương tự) và gán chuỗi `FormDefinition` và `FormData` vào các thuộc tính tương ứng.
4.  **Truyền Model cho View:** Truyền instance ViewModel này tới View (`.cshtml`).

**Trong file Razor nơi gọi (Ví dụ: `CreateModal.cshtml`):**

1.  **Xác định vị trí:** Chọn `div` hoặc container nơi form động sẽ được hiển thị.
2.  **Gọi Partial View:** Sử dụng `@await Html.PartialAsync("_DynamicFormRenderer", Model.YourViewModelInstance)` để render component, truyền vào instance ViewModel đã chuẩn bị ở bước 3 phía trên.

    ```cshtml
    @* Ví dụ trong CreateModal.cshtml *@
    @if (Model.DeclarationComponentData != null) // DeclarationComponentData là BDocumentDataViewModel
    {
        <h5>@L["DeclarationForm"]: @Model.DeclarationComponentData.ComponentName</h5>
        <div id="DeclarationFormContainer" data-component-id="@Model.DeclarationComponentData.ProcedureComponentId" class="border p-3 mb-3">
            @await Html.PartialAsync("_DynamicFormRenderer", Model.DeclarationComponentData)
        </div>
        <hr />
        @* Input ẩn để JS thu thập dữ liệu từ form động *@
        <input type="hidden" name="BDocumentViewModel.ComponentDataList[@Model.DeclarationComponentIndex].FormData" id="declarationFormDataJson" />
        @* Các hidden input khác nếu cần *@
    }
    ```

3.  **JavaScript Thu thập dữ liệu:** Cần có mã JavaScript (ví dụ trong `createModal.js`) để:
    -   Tìm tất cả các input/select/textarea bên trong container (`#DeclarationFormContainer` trong ví dụ) có attribute `data-field-name`.
    -   Đọc giá trị của chúng.
    -   Tạo một đối tượng JavaScript key-value.
    -   Chuyển đối tượng thành chuỗi JSON bằng `JSON.stringify()`.
    -   Gán chuỗi JSON này vào một input ẩn (ví dụ: `#declarationFormDataJson`) để form có thể gửi dữ liệu này lên server khi submit. Hàm này nên được gọi trước khi form submit.

    ```javascript
    // Ví dụ trong createModal.js
    function collectDeclarationFormData() {
        var formData = {};
        $('#DeclarationFormContainer [data-field-name]').each(function() {
            var $input = $(this);
            var fieldName = $input.data('field-name');
            if (!fieldName) return;
            var value = $input.is(':checkbox') ? $input.is(':checked') : $input.val();
            formData[fieldName] = value;
        });
        var jsonString = JSON.stringify(formData);
        $('#declarationFormDataJson').val(jsonString); // Gán vào input ẩn
        return jsonString;
    }

    // Gọi hàm này trong sự kiện submit của form cha
    $('#CreateBDocumentForm').on('submit', function(e) {
        collectDeclarationFormData();
    });
    ```

## 6. Kiểm thử

-   Chuẩn bị các chuỗi JSON `FormDefinition` mẫu:
    -   Bao gồm tất cả các `type` được hỗ trợ (text, textarea, select, date, checkbox, number...).
    -   Có trường `required: true` và `required: false`.
    -   Có `placeholder`, `description`.
    -   `select` có `options`.
    -   Có trường `readonly: true`.
    -   Trường hợp JSON không hợp lệ.
    -   Trường hợp mảng `fields` rỗng hoặc thiếu.
-   Chuẩn bị `FormData` mẫu tương ứng với các `FormDefinition` trên, bao gồm cả trường hợp null hoặc JSON rỗng.
-   Tạo một trang Razor đơn giản để gọi Partial View với các dữ liệu mẫu này.
-   **Kiểm tra:**
    -   Kết quả render HTML có đúng thẻ, đúng class, đúng attribute (`name`, `id`, `required`, `value`, `checked`, `placeholder`, `data-field-name`, `readonly`, `disabled`) không.
    -   Dữ liệu ban đầu từ `FormData` có được điền đúng vào các control không.
    -   Localization có hoạt động cho `label`, `placeholder`, `option text` không (cần định nghĩa key trong file resource).
    -   Xử lý lỗi khi JSON đầu vào không hợp lệ (hiển thị `abp-alert`).
    -   Layout (chia cột) có hoạt động cơ bản không.
    -   Kiểm tra ID được sinh ra có đủ duy nhất không (đặc biệt nếu render nhiều form trên cùng trang).
