# Kế hoạch chi tiết: Tầng Application (`Aqt.CoreFW.Application`) - Quản lý Hồ sơ (BDocument)

Phần này mô tả các thành phần cần tạo hoặc cập nhật trong tầng `Aqt.CoreFW.Application` cho module Quản lý Hồ sơ (BDocument).

## 1. Mapping Logic

### 1.1. Mapping Action for Excel Export (`BDocumentToExcelMappingAction` - Optional)

-   **Mục đích:** Xử lý logic mapping tùy chỉnh khi chuyển đổi từ `BDocument` (Entity) sang `BDocumentExcelDto`, ví dụ lấy tên Thủ tục, tên Trạng thái và định dạng trường boolean.
-   **Vị trí:** Tạo thư mục `src/Aqt.CoreFW.Application/BDocuments` (nếu chưa có)
-   **Tệp:** Tạo file `BDocumentToExcelMappingAction.cs` (Nếu có chức năng Export Excel và cần logic phức tạp hơn AutoMapper Profile)
-   **Nội dung:**
    ```csharp
    using Aqt.CoreFW.Application.Contracts.BDocuments.Dtos; // BDocumentExcelDto
    using Aqt.CoreFW.Domain.BDocuments.Entities; // BDocument Entity
    using Aqt.CoreFW.Domain.WorkflowStatuses; // IWorkflowStatusRepository
    using Aqt.CoreFW.Domain.Procedures; // IProcedureRepository
    using AutoMapper;
    using Volo.Abp.DependencyInjection;
    using System.Threading.Tasks;

    namespace Aqt.CoreFW.Application.BDocuments;

    /// <summary>
    /// Optional AutoMapper mapping action for BDocument to BDocumentExcelDto.
    /// Fetches related names (Procedure, Status) and formats boolean.
    /// Can be replaced by enriching logic in AppService or simpler Profile mapping.
    /// </summary>
    public class BDocumentToExcelMappingAction
        : IMappingAction<BDocument, BDocumentExcelDto>, ITransientDependency
    {
        private readonly IProcedureRepository _procedureRepository;
        private readonly IWorkflowStatusRepository _statusRepository;

        public BDocumentToExcelMappingAction(
            IProcedureRepository procedureRepository,
            IWorkflowStatusRepository statusRepository)
        {
            _procedureRepository = procedureRepository;
            _statusRepository = statusRepository;
        }

        public async Task Process(BDocument source, BDocumentExcelDto destination, ResolutionContext context)
        {
            // Fetch Procedure Name
            var procedure = await _procedureRepository.FindAsync(source.ProcedureId);
            destination.ProcedureName = procedure?.Name ?? string.Empty;

            // Fetch Status Name
            if (source.TrangThaiHoSoId.HasValue)
            {
                 var status = await _statusRepository.FindAsync(source.TrangThaiHoSoId.Value);
                 destination.StatusName = status?.Name ?? string.Empty;
            }
            else
            {
                 destination.StatusName = ""; // Or a localized "Not Set" string
            }


            // Map new fields
            destination.PhamViHoatDong = source.PhamViHoatDong;
            destination.DangKyNhanQuaBuuDien = source.DangKyNhanQuaBuuDien ? "Yes" : "No"; // Format boolean

            // Map dates (can also be done directly in profile)
            destination.NgayNop = source.NgayNop;
            destination.NgayTiepNhan = source.NgayTiepNhan;
            destination.NgayHenTra = source.NgayHenTra;
            destination.NgayTraKetQua = source.NgayTraKetQua;
        }

        // Synchronous version (less ideal)
        public void Process(BDocument source, BDocumentExcelDto destination, ResolutionContext context)
        {
             ProcessAsync(source, destination, context).GetAwaiter().GetResult();
        }

         private async Task ProcessAsync(BDocument source, BDocumentExcelDto destination, ResolutionContext context)
        {
            var procedure = await _procedureRepository.FindAsync(source.ProcedureId);
            destination.ProcedureName = procedure?.Name ?? string.Empty;
             if (source.TrangThaiHoSoId.HasValue) {
                 var status = await _statusRepository.FindAsync(source.TrangThaiHoSoId.Value);
                 destination.StatusName = status?.Name ?? string.Empty;
             } else { destination.StatusName = ""; }
            destination.PhamViHoatDong = source.PhamViHoatDong;
            destination.DangKyNhanQuaBuuDien = source.DangKyNhanQuaBuuDien ? "Yes" : "No";
            destination.NgayNop = source.NgayNop;
            destination.NgayTiepNhan = source.NgayTiepNhan;
            destination.NgayHenTra = source.NgayHenTra;
            destination.NgayTraKetQua = source.NgayTraKetQua;
        }
    }
    ```

### 1.2. AutoMapper Profile (`BDocumentApplicationAutoMapperProfile`)

-   **Vị trí:** Tạo file `src/Aqt.CoreFW.Application/BDocuments/BDocumentApplicationAutoMapperProfile.cs`
-   **Nội dung:**
    ```csharp
    using Aqt.CoreFW.Application.Contracts.BDocuments.Dtos; // DTOs
    using Aqt.CoreFW.Application.Contracts.Files; // FileInfoDto
    using Aqt.CoreFW.Domain.BDocuments.Entities; // Entities
    using AutoMapper;
    using EasyAbp.FileManagement.Files; // File Entity from FileManagement

    namespace Aqt.CoreFW.Application.BDocuments;

    public class BDocumentApplicationAutoMapperProfile : Profile
    {
        public BDocumentApplicationAutoMapperProfile()
        {
            // --- BDocument Mappings ---
            CreateMap<BDocument, BDocumentDto>()
                 .ForMember(dest => dest.Procedure, opt => opt.Ignore()) // Enrich later
                 .ForMember(dest => dest.TrangThaiHoSo, opt => opt.Ignore()); // Enrich later

            CreateMap<BDocument, BDocumentListDto>()
                 .ForMember(dest => dest.ProcedureName, opt => opt.Ignore()) // Enrich later
                 .ForMember(dest => dest.TrangThaiHoSoName, opt => opt.Ignore()) // Enrich later
                 .ForMember(dest => dest.TrangThaiHoSoColorCode, opt => opt.Ignore()); // Enrich later

            // --- BDocumentData Mapping ---
            CreateMap<BDocumentData, BDocumentDataDto>()
                .ForMember(dest => dest.ComponentCode, opt => opt.Ignore()) // Enrich later
                .ForMember(dest => dest.ComponentName, opt => opt.Ignore()) // Enrich later
                .ForMember(dest => dest.ComponentType, opt => opt.Ignore()) // Enrich later
                .ForMember(dest => dest.IsRequired, opt => opt.Ignore())   // Enrich later
                .ForMember(dest => dest.FileInfo, opt => opt.Ignore());    // Enrich later

            // --- Excel Mapping ---
            CreateMap<BDocument, BDocumentExcelDto>()
                 .ForMember(dest => dest.ProcedureName, opt => opt.Ignore()) // Handle in AppService or Action
                 .ForMember(dest => dest.StatusName, opt => opt.Ignore())   // Handle in AppService or Action
                 .ForMember(dest => dest.DangKyNhanQuaBuuDien, opt => opt.MapFrom(src => src.DangKyNhanQuaBuuDien ? "Yes" : "No")); // Simple bool mapping
                 // .AfterMap<BDocumentToExcelMappingAction>(); // Use if complex logic needed

            // --- File Management Mapping ---
             // Map File Entity from FileManagement to our FileInfoDto (if structure matches)
             // Ensure Aqt.CoreFW.Application.Contracts.Files.FileInfoDto has necessary properties
             // (Id, FileName, Length, ContentType)
             CreateMap<File, FileInfoDto>(); // Map File Entity to FileInfoDto Contract

            // --- Input DTOs to Entity Mappings ---
            // NO direct mapping for Create/Update DTOs to Entities. Use Manager service.
        }
    }
    ```

## 2. AppService Implementation (`BDocumentAppService`)

-   **Vị trí:** Tạo file `src/Aqt.CoreFW.Application/BDocuments/BDocumentAppService.cs`
-   **Nội dung:**
    ```csharp
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text.Json; // For JSON handling
    using System.Threading.Tasks;
    using Aqt.CoreFW.Application.Contracts.BDocuments; // Service Interface
    using Aqt.CoreFW.Application.Contracts.BDocuments.Dtos; // DTOs
    using Aqt.CoreFW.Application.Contracts.Files; // FileInfoDto
    using Aqt.CoreFW.Application.Contracts.Procedures.Dtos; // ProcedureDto
    using Aqt.CoreFW.Application.Contracts.WorkflowStatuses.Dtos; // WorkflowStatusDto
    using Aqt.CoreFW.BDocuments; // Constants
    using Aqt.CoreFW.Components; // ComponentType Enum
    using Aqt.CoreFW.Domain.BDocuments; // Domain Service and Repository
    using Aqt.CoreFW.Domain.BDocuments.Entities; // Entities
    using Aqt.CoreFW.Domain.Components; // Component Repository & Entity
    using Aqt.CoreFW.Domain.Components.Entities;
    using Aqt.CoreFW.Domain.Procedures; // Procedure Repository & Entity
    using Aqt.CoreFW.Domain.Procedures.Entities;
    using Aqt.CoreFW.Domain.WorkflowStatuses; // Status Repository & Entity
    using Aqt.CoreFW.Domain.WorkflowStatuses.Entities;
    using Aqt.CoreFW.Localization; // Resource
    using Aqt.CoreFW.Permissions; // Permissions
    using Aqt.CoreFW.Shared.Services; // For IAbpExcelExportHelper (Optional)
    using EasyAbp.FileManagement.Files; // IFileAppService, IFileManager, File Entity, CreateFileInput
    using Microsoft.AspNetCore.Authorization;
    using Microsoft.Extensions.Localization;
    using Volo.Abp;
    using Volo.Abp.Application.Dtos;
    using Volo.Abp.Application.Services;
    using Volo.Abp.Content; // For IRemoteStreamContent
    using Volo.Abp.Domain.Entities; // For EntityNotFoundException
    using Volo.Abp.Guids;
    using Volo.Abp.ObjectMapping;
    using Volo.Abp.Uow; // UnitOfWork
    using Volo.Abp.Validation; // AbpValidationException

    namespace Aqt.CoreFW.Application.BDocuments;

    [Authorize(CoreFWPermissions.BDocuments.Default)]
    public class BDocumentAppService : ApplicationService, IBDocumentAppService
    {
        private readonly IBDocumentRepository _bDocumentRepository;
        private readonly BDocumentManager _bDocumentManager;
        private readonly IProcedureRepository _procedureRepository;
        private readonly IWorkflowStatusRepository _statusRepository;
        private readonly IProcedureComponentRepository _componentRepository;
        private readonly IFileAppService _fileAppService; // File Management AppService
        private readonly IFileManager _fileManager;       // File Management Domain Service
        private readonly IGuidGenerator _guidGenerator;
        private readonly IStringLocalizer<CoreFWResource> _localizer;
        private readonly IAbpExcelExportHelper? _excelExportHelper; // Optional for Excel
        private readonly IValidationErrorHandler _validationErrorHandler; // To handle validation exceptions

        public BDocumentAppService(
            IBDocumentRepository bDocumentRepository,
            BDocumentManager bDocumentManager,
            IProcedureRepository procedureRepository,
            IWorkflowStatusRepository statusRepository,
            IProcedureComponentRepository componentRepository,
            IFileAppService fileAppService,
            IFileManager fileManager, // Inject FileManager
            IGuidGenerator guidGenerator,
            IStringLocalizer<CoreFWResource> localizer,
            IValidationErrorHandler validationErrorHandler,
            IAbpExcelExportHelper? excelExportHelper = null)
        {
            _bDocumentRepository = bDocumentRepository;
            _bDocumentManager = bDocumentManager;
            _procedureRepository = procedureRepository;
            _statusRepository = statusRepository;
            _componentRepository = componentRepository;
            _fileAppService = fileAppService;
            _fileManager = fileManager; // Assign FileManager
            _guidGenerator = guidGenerator;
            _localizer = localizer;
            _validationErrorHandler = validationErrorHandler;
            _excelExportHelper = excelExportHelper;

            LocalizationResource = typeof(CoreFWResource);
        }

        [Authorize(CoreFWPermissions.BDocuments.Create)]
        [UnitOfWork]
        public async Task<BDocumentDto> CreateAsync(CreateBDocumentInputDto input)
        {
            // 1. Generate document code
            string maHoSo = "HS-" + Clock.Now.ToString("yyyyMMddHHmmssfff");

            // 2. Create BDocument entity using Manager (without components yet)
            var bDocument = await _bDocumentManager.CreateAsync(
                input.ProcedureId,
                maHoSo,
                input.TenChuHoSo,
                input.SoDinhDanhChuHoSo,
                input.DiaChiChuHoSo,
                input.EmailChuHoSo,
                input.SoDienThoaiChuHoSo,
                input.PhamViHoatDong,
                input.DangKyNhanQuaBuuDien,
                Clock.Now // NgayNop
            );

            // 3. Add initial component data
            if (input.ComponentData != null && input.ComponentData.Any())
            {
                var components = await _componentRepository.GetListAsync(procedureId: input.ProcedureId);

                foreach (var componentInput in input.ComponentData)
                {
                    var componentDef = components.FirstOrDefault(c => c.Id == componentInput.ProcedureComponentId);
                    if (componentDef == null) continue; // Skip invalid components

                    // Validate data type consistency (delegated to Manager)
                    _bDocumentManager.ValidateComponentDataType(componentDef, componentInput.FormData, componentInput.FileId);

                    // Validate declaration form data (if applicable)
                    if (componentDef.Code == BDocumentConsts.DeclarationFormComponentCode)
                    {
                       // ValidateDeclarationFormData(componentInput.FormData, componentDef.FormDefinition);
                    }

                    // Validate file existence (if FileId provided)
                    if (componentInput.FileId.HasValue)
                    {
                        // Optional: Check if file actually exists via FileManagement
                       // await _bDocumentManager.ValidateFileExistsAsync(componentInput.FileId.Value);
                       // Or rely on subsequent operations failing if file is invalid
                    }

                    // Add data using Manager
                    await _bDocumentManager.AddOrUpdateComponentDataAsync(
                        bDocument,
                        componentInput.ProcedureComponentId,
                        componentInput.FormData, // Contains declaration JSON
                        componentInput.FileId // Contains uploaded file ID
                    );
                }
            }

            // 4. Save BDocument (UoW handles BDocumentData persistence)
            await _bDocumentRepository.InsertAsync(bDocument, autoSave: true);

            // 5. Trigger Workflow (optional, could be event-driven)
            // await _workflowManager.StartWorkflowAsync("BDocumentWorkflow", bDocument.Id);

            // 6. Return detailed DTO
            return await GetAsync(bDocument.Id);
        }

        [Authorize(CoreFWPermissions.BDocuments.Update)]
        [UnitOfWork]
        public async Task<BDocumentDto> UpdateAsync(Guid id, UpdateBDocumentInputDto input)
        {
            var bDocument = await _bDocumentRepository.GetAsync(id);
            // TODO: Check status allowance using _bDocumentManager.ValidateUpdatableStatusAsync(bDocument);

            // Call Manager to update main info
            await _bDocumentManager.UpdateInfoAsync(
                 bDocument,
                 input.TenChuHoSo,
                 input.SoDinhDanhChuHoSo,
                 input.DiaChiChuHoSo,
                 input.EmailChuHoSo,
                 input.SoDienThoaiChuHoSo,
                 input.PhamViHoatDong,
                 input.DangKyNhanQuaBuuDien
             );

            await _bDocumentRepository.UpdateAsync(bDocument, autoSave: true);
            return await GetAsync(id);
        }

        public async Task<BDocumentDto> GetAsync(Guid id)
        {
            var bDocument = await _bDocumentRepository.GetWithDataAsync(id); // Ensure DocumentData is loaded
            if (bDocument == null)
            {
                throw new EntityNotFoundException(typeof(BDocument), id);
            }

            var dto = ObjectMapper.Map<BDocument, BDocumentDto>(bDocument);

            // Enrich with Procedure Info
            var procedure = await _procedureRepository.FindAsync(bDocument.ProcedureId);
            if (procedure != null)
            {
                dto.Procedure = ObjectMapper.Map<Procedure, ProcedureDto>(procedure);
            }

            // Enrich with WorkflowStatus Info
            if (bDocument.TrangThaiHoSoId.HasValue)
            {
                 var status = await _statusRepository.FindAsync(bDocument.TrangThaiHoSoId.Value);
                 if (status != null)
                 {
                     dto.TrangThaiHoSo = ObjectMapper.Map<WorkflowStatus, WorkflowStatusDto>(status);
                 }
            }


            // Enrich DocumentData with Component and File Info
            if (dto.DocumentData.Any())
            {
                var componentIds = dto.DocumentData.Select(d => d.ProcedureComponentId).Distinct().ToList();
                var fileIds = dto.DocumentData.Where(d => d.FileId.HasValue).Select(d => d.FileId!.Value).Distinct().ToList();

                var components = (await _componentRepository.GetListAsync(ids: componentIds)).ToDictionary(c => c.Id);
                var fileInfos = new Dictionary<Guid, FileInfoDto>();
                if (fileIds.Any())
                {
                    // Use FileAppService to get File DTOs
                    try
                    {
                        // Ideally use a GetManyAsync if available, otherwise loop
                        foreach(var fileId in fileIds)
                        {
                           // Check FileManagement read permission implicitly?
                           var fileDto = await _fileAppService.GetAsync(fileId); // File DTO from FileManagement
                           // Map the FileManagement DTO to our FileInfoDto contract if necessary,
                           // or ensure FileInfoDto matches FileManagement's DTO structure.
                           // Assuming direct mapping works here or FileInfoDto is identical.
                           fileInfos[fileId] = ObjectMapper.Map<EasyAbp.FileManagement.Files.Dtos.FileInfoDto, FileInfoDto>(fileDto); // Explicit map
                        }
                    }
                    catch (Exception ex)
                    {
                         Logger.LogError(ex, "Error fetching file info from FileManagement for BDocument {BDocumentId}", id);
                    }
                }

                // Populate details in BDocumentDataDto list
                foreach (var dataDto in dto.DocumentData)
                {
                    if (components.TryGetValue(dataDto.ProcedureComponentId, out var component))
                    {
                        dataDto.ComponentCode = component.Code;
                        dataDto.ComponentName = component.Name;
                        dataDto.ComponentType = component.Type;
                        // TODO: Fetch IsRequired flag (needs ProcedureComponentLink info)
                        // dataDto.IsRequired = ...;
                    }

                    if (dataDto.FileId.HasValue && fileInfos.TryGetValue(dataDto.FileId.Value, out var fileInfo))
                    {
                        dataDto.FileInfo = fileInfo;
                    }
                }
            }

            return dto;
        }

        public async Task<PagedResultDto<BDocumentListDto>> GetListAsync(GetBDocumentsInput input)
        {
            var totalCount = await _bDocumentRepository.GetCountAsync(
                filterText: input.Filter,
                procedureId: input.ProcedureId,
                trangThaiHoSoId: input.StatusId,
                ngayNopFrom: input.SubmissionDateFrom,
                ngayNopTo: input.SubmissionDateTo
                // Add filter for DangKyNhanQuaBuuDien if implemented
            );

            var bDocuments = await _bDocumentRepository.GetListAsync(
                filterText: input.Filter,
                procedureId: input.ProcedureId,
                trangThaiHoSoId: input.StatusId,
                ngayNopFrom: input.SubmissionDateFrom,
                ngayNopTo: input.SubmissionDateTo,
                // Add filter for DangKyNhanQuaBuuDien if implemented
                sorting: input.Sorting ?? $"{nameof(BDocument.CreationTime)} DESC",
                maxResultCount: input.MaxResultCount,
                skipCount: input.SkipCount,
                includeDetails: false
            );

            var dtos = ObjectMapper.Map<List<BDocument>, List<BDocumentListDto>>(bDocuments);

            // Enrich with Procedure and Status names/colors
            if (dtos.Any())
            {
                var procedureIds = dtos.Select(d => d.ProcedureId).Distinct().ToList();
                var statusIds = dtos.Where(d => d.TrangThaiHoSoId.HasValue).Select(d => d.TrangThaiHoSoId!.Value).Distinct().ToList();

                var procedures = (await _procedureRepository.GetListAsync(ids: procedureIds)).ToDictionary(p => p.Id);
                var statuses = new Dictionary<Guid, WorkflowStatus>();
                 if (statusIds.Any()) {
                     statuses = (await _statusRepository.GetListAsync(ids: statusIds)).ToDictionary(s => s.Id);
                 }


                foreach (var dto in dtos)
                {
                    if (procedures.TryGetValue(dto.ProcedureId, out var procedure))
                    {
                        dto.ProcedureName = procedure.Name;
                    }
                     if (dto.TrangThaiHoSoId.HasValue && statuses.TryGetValue(dto.TrangThaiHoSoId.Value, out var status))
                    {
                        dto.TrangThaiHoSoName = status.Name;
                        dto.TrangThaiHoSoColorCode = status.ColorCode;
                    }
                    else
                    {
                        // Handle null status name if needed (e.g., localized "Not Set")
                        dto.TrangThaiHoSoName = _localizer["NotSet"] ?? "Not Set";
                    }
                }
            }

            return new PagedResultDto<BDocumentListDto>(totalCount, dtos);
        }

        [Authorize(CoreFWPermissions.BDocuments.Delete)]
        [UnitOfWork]
        public virtual async Task DeleteAsync(Guid id)
        {
            var bDocument = await _bDocumentRepository.GetWithDataAsync(id); // Get with data for potential file deletion
             if (bDocument == null)
            {
                throw new EntityNotFoundException(typeof(BDocument), id);
            }
            // TODO: Check status allowance using _bDocumentManager.ValidateDeletableStatusAsync(bDocument);

            // Decide on file deletion policy
            // bool deleteFiles = false; // Configurable?
            // if (deleteFiles)
            // {
            //     foreach (var data in bDocument.DocumentData.Where(d => d.FileId.HasValue))
            //     {
            //         await _bDocumentManager.DeleteFileAsync(data.FileId.Value, bDocument.Id, data.ProcedureComponentId); // Use manager for file deletion
            //     }
            // }

            await _bDocumentRepository.DeleteAsync(id, autoSave: true); // Soft delete BDocument & cascade BDocumentData
        }

        [Authorize(CoreFWPermissions.BDocuments.ManageComponents)]
        [UnitOfWork]
        public async Task<BDocumentDataDto> AddOrUpdateDataAsync(Guid id, AddOrUpdateBDocumentDataInputDto input)
        {
            var bDocument = await _bDocumentRepository.GetAsync(id);
            // TODO: Check status allowance: await _bDocumentManager.ValidateUpdatableComponentDataStatusAsync(bDocument);

            // TODO: Validate declaration form JSON if component is declaration form
            // var component = await _componentRepository.GetAsync(input.ProcedureComponentId);
            // if(component.Code == BDocumentConsts.DeclarationFormComponentCode) {
            //    ValidateDeclarationFormData(input.FormData, component.FormDefinition);
            // }

            await _bDocumentManager.AddOrUpdateComponentDataAsync(
                bDocument,
                input.ProcedureComponentId,
                input.FormData,
                input.FileId
            );

            await _bDocumentRepository.UpdateAsync(bDocument, autoSave: true);

            var updatedData = (await _bDocumentRepository.GetWithDataAsync(id))?
                                .DocumentData.FirstOrDefault(d => d.ProcedureComponentId == input.ProcedureComponentId);

            if (updatedData == null)
            {
                 throw new UserFriendlyException("Failed to retrieve updated document data."); // Specific error
            }

            return await EnrichBDocumentDataDtoAsync(updatedData);
        }

        [Authorize(CoreFWPermissions.BDocuments.ManageComponents)]
        [UnitOfWork]
        public async Task RemoveDataAsync(Guid id, Guid bDocumentDataId, bool deleteFile = false)
        {
            var bDocument = await _bDocumentRepository.GetWithDataAsync(id);
             if (bDocument == null) throw new EntityNotFoundException(typeof(BDocument), id);
            // TODO: Check status allowance: await _bDocumentManager.ValidateUpdatableComponentDataStatusAsync(bDocument);

             var dataToRemove = bDocument.DocumentData.FirstOrDefault(d => d.Id == bDocumentDataId);
             if (dataToRemove == null) return;

            // Use Manager to handle removal and potential file deletion
            await _bDocumentManager.RemoveComponentDataAsync(
                bDocument,
                dataToRemove.ProcedureComponentId,
                deleteFile
            );

            await _bDocumentRepository.UpdateAsync(bDocument, autoSave: true);
        }


        [Authorize(CoreFWPermissions.BDocuments.Update)] // Or specific workflow permission
        [UnitOfWork]
        public async Task<BDocumentDto> ChangeStatusAsync(Guid id, ChangeBDocumentStatusInputDto input)
        {
            var bDocument = await _bDocumentRepository.GetAsync(id);
            // Check permission specifically for status change if needed

            await _bDocumentManager.ChangeStatusAsync(
                bDocument,
                input.NewStatusId,
                input.Reason
            );

            await _bDocumentRepository.UpdateAsync(bDocument, autoSave: true);
            return await GetAsync(id);
        }


        [Authorize(CoreFWPermissions.BDocuments.GenerateDeclarationFile)]
        [UnitOfWork]
        public async Task<FileInfoDto> GenerateDeclarationFileAsync(Guid id)
        {
            var bDocument = await _bDocumentRepository.GetWithDataAsync(id);
            if (bDocument == null) throw new EntityNotFoundException(typeof(BDocument), id);
             // TODO: Check status allowance for generation?

            // 1. Find Declaration Component and Data
            var declarationComponentDef = (await _componentRepository.GetListAsync(procedureId: bDocument.ProcedureId))
                                          .FirstOrDefault(c => c.Code == BDocumentConsts.DeclarationFormComponentCode && c.Type == ComponentType.Form);
            if (declarationComponentDef == null) throw new UserFriendlyException(L[CoreFWDomainErrorCodes.DeclarationFormComponentNotFound]);

            var declarationData = bDocument.DocumentData.FirstOrDefault(d => d.ProcedureComponentId == declarationComponentDef.Id);
            if (declarationData == null || string.IsNullOrWhiteSpace(declarationData.DuLieuNhap))
            {
                throw new UserFriendlyException(L[CoreFWDomainErrorCodes.RequiredComponentDataMissing, declarationComponentDef.Name]);
            }

            // 2. Deserialize JSON
            object? formDataObject;
            try {
                formDataObject = JsonSerializer.Deserialize<Dictionary<string, object>>(declarationData.DuLieuNhap);
                 if(formDataObject == null) throw new Exception("Deserialized form data is null.");
            } catch (Exception ex) {
                Logger.LogError(ex, "Failed to deserialize declaration form data for BDocument {Id}", id);
                throw new UserFriendlyException(L[CoreFWDomainErrorCodes.InvalidFormDataForDeclaration, ex.Message]);
            }

            // 3. Get Template Content (Placeholder)
            // var templateContent = await GetTemplateContentAsync(declarationComponentDef.TempPath);

            // 4. Render Template (Placeholder)
            byte[] generatedFileBytes;
            string generatedFileName = $"ToKhai_{bDocument.MaHoSo}.pdf"; // Example name
            string mimeType = MimeTypes.GetMimeType(generatedFileName); // Use helper for MIME type
            try {
                 // generatedFileBytes = await _templateRenderer.RenderAsync(templateContent, formDataObject);
                 generatedFileBytes = System.Text.Encoding.UTF8.GetBytes($"Simulated PDF content for {bDocument.MaHoSo}\nData: {declarationData.DuLieuNhap}"); // Simulation
            } catch (Exception ex) {
                 Logger.LogError(ex, "Failed to render declaration file for BDocument {Id}", id);
                 throw new UserFriendlyException(L[CoreFWDomainErrorCodes.DeclarationFileGenerationFailed, ex.Message]);
            }

            // 5. Upload Generated File
            File createdFile;
            try {
                var createFileInput = new CreateFileInput
                {
                    FileContainerName = "bdocuments", // Configurable container name
                    FileName = generatedFileName,
                    Bytes = generatedFileBytes,
                    FileType = FileType.RegularFile
                };
                createdFile = await _fileAppService.CreateAsync(createFileInput);
            } catch (Exception ex) {
                 Logger.LogError(ex, "Failed to upload generated declaration file for BDocument {Id}", id);
                 throw new UserFriendlyException(L[CoreFWDomainErrorCodes.FileManagementInteractionFailed, ex.Message]);
            }


            // 6. Update BDocumentData with new FileId
            await _bDocumentManager.AddOrUpdateComponentDataAsync(bDocument, declarationData.ProcedureComponentId, declarationData.DuLieuNhap, createdFile.Id);
            // Optionally clear DuLieuNhap after successful generation:
            // await _bDocumentManager.AddOrUpdateComponentDataAsync(bDocument, declarationData.ProcedureComponentId, null, createdFile.Id);

            await _bDocumentRepository.UpdateAsync(bDocument, autoSave: true);

            // 7. Return File Info DTO
            return ObjectMapper.Map<File, FileInfoDto>(createdFile);
        }


        [Authorize(CoreFWPermissions.BDocuments.Export)]
        public async Task<IRemoteStreamContent> GetListAsExcelAsync(GetBDocumentsInput input)
        {
            if (_excelExportHelper == null)
            {
                throw new UserFriendlyException("Excel export service is not configured.");
            }

            var bDocuments = await _bDocumentRepository.GetListAsync(
                filterText: input.Filter,
                procedureId: input.ProcedureId,
                trangThaiHoSoId: input.StatusId,
                ngayNopFrom: input.SubmissionDateFrom,
                ngayNopTo: input.SubmissionDateTo,
                sorting: input.Sorting ?? $"{nameof(BDocument.CreationTime)} DESC",
                maxResultCount: int.MaxValue,
                skipCount: 0,
                includeDetails: false
            );

             var excelDtos = new List<BDocumentExcelDto>();
             if (bDocuments.Any())
             {
                 var procedureIds = bDocuments.Select(d => d.ProcedureId).Distinct().ToList();
                 var statusIds = bDocuments.Where(d=>d.TrangThaiHoSoId.HasValue).Select(d => d.TrangThaiHoSoId!.Value).Distinct().ToList();
                 var procedures = (await _procedureRepository.GetListAsync(ids: procedureIds)).ToDictionary(p => p.Id);
                 var statuses = new Dictionary<Guid, WorkflowStatus>();
                  if(statusIds.Any()) statuses = (await _statusRepository.GetListAsync(ids: statusIds)).ToDictionary(s => s.Id);

                 // Map using AutoMapper first
                 excelDtos = ObjectMapper.Map<List<BDocument>, List<BDocumentExcelDto>>(bDocuments);

                 // Enrich names
                 foreach (var dto in excelDtos)
                 {
                     var bDoc = bDocuments.First(b => b.MaHoSo == dto.MaHoSo); // Find original by unique key
                     if (procedures.TryGetValue(bDoc.ProcedureId, out var p)) dto.ProcedureName = p.Name;
                     if (bDoc.TrangThaiHoSoId.HasValue && statuses.TryGetValue(bDoc.TrangThaiHoSoId.Value, out var s)) dto.StatusName = s.Name;
                     else dto.StatusName = ""; // Handle null status
                     // Boolean formatting handled by AutoMapper Profile
                 }
             }

            var fileContent = await _excelExportHelper.ExportToExcelAsync(excelDtos, "BDocuments");
            return fileContent;
        }

        // --- Helper Methods ---
         private async Task<BDocumentDataDto> EnrichBDocumentDataDtoAsync(BDocumentData data) {
            var dto = ObjectMapper.Map<BDocumentData, BDocumentDataDto>(data);
            var component = await _componentRepository.FindAsync(data.ProcedureComponentId);
             if (component != null) {
                 dto.ComponentCode = component.Code;
                 dto.ComponentName = component.Name;
                 dto.ComponentType = component.Type;
                 // TODO: Fetch IsRequired from link table if needed
             }
             if (data.FileId.HasValue) {
                 try {
                     var fileDtoFm = await _fileAppService.GetAsync(data.FileId.Value);
                     dto.FileInfo = ObjectMapper.Map<EasyAbp.FileManagement.Files.Dtos.FileInfoDto, FileInfoDto>(fileDtoFm); // Explicit map
                 }
                 catch (Exception ex) { Logger.LogError(ex, "Error fetching FileInfo for BDocumentData {Id}", data.Id); }
             }
             return dto;
         }

         // private void ValidateDeclarationFormData(string? jsonData, string? formDefinitionJson) {
         //    if (string.IsNullOrWhiteSpace(jsonData)) throw new UserFriendlyException("Declaration form data cannot be empty.");
         //    // TODO: Implement validation logic based on formDefinitionJson
         //    // E.g., Deserialize both, check required fields, types, etc.
         // }

         // Placeholder for template rendering logic
         // private async Task<byte[]> RenderTemplateAsync(string templateContent, object data) { ... }
         // private async Task<string> GetTemplateContentAsync(string templatePath) { ... }
    }
    ```

## 3. Cập nhật `CoreFWApplicationModule.cs`

-   **Vị trí:** `src/Aqt.CoreFW.Application/CoreFWApplicationModule.cs`
-   **Hành động:** Đảm bảo module có dependency đến `FileManagementApplicationContractsModule`.
-   **Nội dung cần thêm/cập nhật:**
    ```csharp
     [DependsOn(
         // ... other dependencies ...
         typeof(FileManagementApplicationContractsModule), // Ensure this is present
         typeof(FileManagementDomainModule) // Maybe needed if using IFileManager directly
     )]
     public class CoreFWApplicationModule : AbpModule
     {
         public override void ConfigureServices(ServiceConfigurationContext context)
         {
              Configure<AbpAutoMapperOptions>(options =>
              {
                  options.AddMaps<CoreFWApplicationModule>(validate: true);
              });
              // ... other configurations ...
         }
     }
    ```

## 4. Lưu ý

*   **Dependency Injection:** `BDocumentAppService` giờ đây inject cả `IFileAppService` và `IFileManager` để có thể vừa sử dụng các phương thức tiện ích của AppService, vừa có thể dùng các phương thức cấp thấp hơn của Domain Service nếu cần (ví dụ: `_fileManager.FindAsync`).
*   **Mapping & Enrichment:** AutoMapper Profile được cập nhật. Logic Enrich trong `GetAsync` và `GetListAsync` được duy trì. Cần đảm bảo map đúng giữa DTO của FileManagement và `FileInfoDto` của contract trong project này.
*   **Domain Service Usage:** Logic nghiệp vụ cốt lõi vẫn nằm trong `BDocumentManager`. AppService chịu trách nhiệm điều phối, validation đầu vào, enrich DTO, và gọi các service khác (FileManagement, Workflow...).
*   **File Management:** Tương tác với file được chuẩn hóa qua `IFileAppService` và `IFileManager`.
*   **Workflow Logic:** Trạng thái ban đầu là null. `ChangeStatusAsync` gọi Manager để xử lý. Logic tạo file từ Tờ khai (`GenerateDeclarationFileAsync`) đã được thêm vào AppService.
*   **Transaction Management:** Sử dụng `[UnitOfWork]` cho các phương thức thay đổi dữ liệu.
*   **Templating/File Generation:** Logic chi tiết cho việc lấy template và render file cần được triển khai trong `GenerateDeclarationFileAsync` hoặc tách ra service riêng.
*   **Validation:** Validation dữ liệu Tờ khai động cần được xem xét kỹ lưỡng.