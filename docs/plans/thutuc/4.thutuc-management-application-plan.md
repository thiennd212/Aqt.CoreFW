# Kế hoạch chi tiết: Tầng Application (`Aqt.CoreFW.Application`) - Quản lý Thủ tục hành chính (Procedure)

Phần này mô tả các thành phần cần tạo hoặc cập nhật trong tầng `Aqt.CoreFW.Application` cho module Quản lý Thủ tục hành chính (Procedure).

## 1. Mapping Logic

### 1.1. Mapping Action for Excel Export (`ProcedureToExcelMappingAction` - Optional)

-   **Mục đích:** Xử lý logic mapping tùy chỉnh khi chuyển đổi từ `Procedure` (Entity) sang `ProcedureExcelDto`, chủ yếu để địa phương hóa `StatusText`.
-   **Vị trí:** Tạo thư mục `src/Aqt.CoreFW.Application/Procedures` (nếu chưa có)
-   **Tệp:** Tạo file `ProcedureToExcelMappingAction.cs` (Nếu có chức năng Export Excel)
-   **Nội dung:**
    ```csharp
    using Aqt.CoreFW.Application.Contracts.Procedures.Dtos; // ProcedureExcelDto
    using Aqt.CoreFW.Domain.Procedures.Entities; // Procedure Entity
    using Aqt.CoreFW.Localization; // CoreFWResource for L[]
    using AutoMapper;
    using Microsoft.Extensions.Localization; // Required for IStringLocalizer
    using Volo.Abp.DependencyInjection; // Required for ITransientDependency

    namespace Aqt.CoreFW.Application.Procedures; // Namespace for Procedure Application layer

    /// <summary>
    /// AutoMapper mapping action to handle specific logic when mapping
    /// from Procedure entity to ProcedureExcelDto.
    /// Primarily handles localization of the Status enum.
    /// </summary>
    public class ProcedureToExcelMappingAction
        : IMappingAction<Procedure, ProcedureExcelDto>, ITransientDependency
    {
        private readonly IStringLocalizer<CoreFWResource> _localizer;

        public ProcedureToExcelMappingAction(IStringLocalizer<CoreFWResource> localizer)
        {
            _localizer = localizer;
        }

        public void Process(Procedure source, ProcedureExcelDto destination, ResolutionContext context)
        {
            // Localize the Status enum
            destination.StatusText = _localizer[$"Enum:ProcedureStatus.{(int)source.Status}"];
        }
    }
    ```

### 1.2. AutoMapper Profile (`ProcedureApplicationAutoMapperProfile`)

-   **Vị trí:** Tạo file `src/Aqt.CoreFW.Application/Procedures/ProcedureApplicationAutoMapperProfile.cs`
-   **Nội dung:**
    ```csharp
    using Aqt.CoreFW.Application.Contracts.Procedures.Dtos; // DTOs for Procedure
    using Aqt.CoreFW.Application.Contracts.Shared.Lookups; // Lookup DTOs
    using Aqt.CoreFW.Domain.Procedures.Entities; // Procedure Entity
    using AutoMapper;

    namespace Aqt.CoreFW.Application.Procedures; // Namespace for Procedure Application layer

    public class ProcedureApplicationAutoMapperProfile : Profile
    {
        public ProcedureApplicationAutoMapperProfile()
        {
            // --- Procedure Mappings ---
            CreateMap<Procedure, ProcedureDto>();

            // Map DTO to DTO for edit form prepopulation (optional but convenient)
            CreateMap<ProcedureDto, CreateUpdateProcedureDto>();

            // Map Entity to Lookup DTO
            CreateMap<Procedure, ProcedureLookupDto>();

            // Map Entity to Excel DTO (if Excel Export is implemented)
            CreateMap<Procedure, ProcedureExcelDto>()
                .ForMember(dest => dest.StatusText, opt => opt.Ignore()) // Handled by MappingAction or AppService
                .AfterMap<ProcedureToExcelMappingAction>(); // Apply action if StatusText is the only custom logic
                // If more complex logic needed in AppService, remove AfterMap

            // No direct mapping from CreateUpdateProcedureDto to Procedure entity
            // Create/Update operations use DTO data with ProcedureManager
        }
    }
    ```

## 2. AppService Implementation (`ProcedureAppService`)

-   **Vị trí:** Tạo file `src/Aqt.CoreFW.Application/Procedures/ProcedureAppService.cs`
-   **Nội dung:**
    ```csharp
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Linq.Dynamic.Core; // Required for dynamic sorting
    using System.Threading.Tasks;
    using Aqt.CoreFW.Application.Contracts.Procedures; // Contracts namespace
    using Aqt.CoreFW.Application.Contracts.Procedures.Dtos; // DTOs namespace
    using Aqt.CoreFW.Application.Contracts.Shared.Lookups; // Lookup DTO namespace
    using Aqt.CoreFW.Shared.Services; // IAbpExcelExportHelper namespace (nếu dùng)
    using Aqt.CoreFW.Domain.Procedures; // Domain Service and Repository Interface namespace
    using Aqt.CoreFW.Domain.Procedures.Entities; // Entity namespace
    using Aqt.CoreFW.Localization; // Resource namespace
    using Aqt.CoreFW.Permissions; // Permissions namespace
    using Aqt.CoreFW.Procedures; // Enum namespace from Domain.Shared
    using Microsoft.AspNetCore.Authorization;
    using Microsoft.Extensions.Localization;
    using Volo.Abp;
    using Volo.Abp.Application.Dtos;
    using Volo.Abp.Application.Services;
    using Volo.Abp.Content; // For IRemoteStreamContent
    using Volo.Abp.ObjectMapping; // For ObjectMapper

    namespace Aqt.CoreFW.Application.Procedures; // Application Service namespace

    [Authorize(CoreFWPermissions.Procedures.Default)] // Default policy for read
    public class ProcedureAppService :
        CrudAppService<
            Procedure,                   // Entity
            ProcedureDto,                // DTO Read
            Guid,                          // Primary Key
            GetProceduresInput,           // DTO for GetList input
            CreateUpdateProcedureDto>,   // DTO for Create/Update input
        IProcedureAppService             // Implement the contract interface
    {
        private readonly IProcedureRepository _procedureRepository;
        private readonly ProcedureManager _procedureManager;
        private readonly IStringLocalizer<CoreFWResource> _localizer;
        private readonly IAbpExcelExportHelper? _excelExportHelper; // Optional: For Excel export

        // Constructor injection
        public ProcedureAppService(
            IProcedureRepository procedureRepository, // Use specific repo
            ProcedureManager procedureManager,
            IStringLocalizer<CoreFWResource> localizer,
            IAbpExcelExportHelper? excelExportHelper = null) // Optional injection
            : base(procedureRepository) // Pass specific repo to base
        {
            _procedureRepository = procedureRepository;
            _procedureManager = procedureManager;
            _localizer = localizer;
            _excelExportHelper = excelExportHelper;

            // Set permission policies from Contracts
            GetPolicyName = CoreFWPermissions.Procedures.Default;
            GetListPolicyName = CoreFWPermissions.Procedures.Default;
            CreatePolicyName = CoreFWPermissions.Procedures.Create;
            UpdatePolicyName = CoreFWPermissions.Procedures.Update;
            DeletePolicyName = CoreFWPermissions.Procedures.Delete;
        }

        // --- Overridden CRUD Methods ---

        [Authorize(CoreFWPermissions.Procedures.Create)]
        public override async Task<ProcedureDto> CreateAsync(CreateUpdateProcedureDto input)
        {
            // Use ProcedureManager to create, handling code uniqueness
            var entity = await _procedureManager.CreateAsync(
                input.Code,
                input.Name,
                input.Order,
                input.Description,
                input.Status
            );

            await _procedureRepository.InsertAsync(entity, autoSave: true);
            return ObjectMapper.Map<Procedure, ProcedureDto>(entity);
        }

        [Authorize(CoreFWPermissions.Procedures.Update)]
        public override async Task<ProcedureDto> UpdateAsync(Guid id, CreateUpdateProcedureDto input)
        {
            var entity = await _procedureRepository.GetAsync(id); // Get entity

            // Code is immutable, check if user tried to change it via DTO
            if (!string.Equals(entity.Code, input.Code, StringComparison.OrdinalIgnoreCase))
            {
                // TODO: Localize this exception message or use a specific ErrorCode
                throw new UserFriendlyException("Changing the Procedure Code is not allowed.");
            }

            // Use manager to handle the update (validation happens in manager/entity setters)
            entity = await _procedureManager.UpdateAsync(
                entity,
                input.Name,
                input.Order,
                input.Description,
                input.Status
            );

            await _procedureRepository.UpdateAsync(entity, autoSave: true);
            return ObjectMapper.Map<Procedure, ProcedureDto>(entity);
        }

        // GetAsync: Base implementation is sufficient as no related data needs mapping here.

        // GetListAsync: Base implementation handles filtering/sorting/paging, but we might optimize filtering.
        public override async Task<PagedResultDto<ProcedureDto>> GetListAsync(GetProceduresInput input)
        {
            // Consider overriding ApplySorting and CreateFilteredQuery if complex filtering is needed
            // For simple filtering by text and status, the specific repository methods are good

            var totalCount = await _procedureRepository.GetCountAsync(
                filterText: input.Filter,
                status: input.Status
            );

            var entities = await _procedureRepository.GetListAsync(
                filterText: input.Filter,
                status: input.Status,
                sorting: input.Sorting ?? "Order ASC, Name ASC", // Default sort
                maxResultCount: input.MaxResultCount,
                skipCount: input.SkipCount
            );

            var dtos = ObjectMapper.Map<List<Procedure>, List<ProcedureDto>>(entities);

            return new PagedResultDto<ProcedureDto>(totalCount, dtos);
        }

        // --- Custom AppService Methods ---

        // Chỉ yêu cầu đã đăng nhập, không cần quyền cụ thể
        [Authorize]
        // [Authorize(CoreFWPermissions.Procedures.Default)] // Use read permission
        public async Task<ListResultDto<ProcedureLookupDto>> GetLookupAsync()
        {
            // Filter for active procedures, sort by Order then Name
            var procedures = await _procedureRepository.GetLookupAsync( // Sử dụng phương thức GetLookupAsync đã thêm ở plan 2
                // status: ProcedureStatus.Active, // Không cần filter status ở đây nữa nếu GetLookupAsync đã làm
                // sorting: "Order ASC, Name ASC" // Không cần sort ở đây nữa nếu GetLookupAsync đã làm
            );

            var dtos = ObjectMapper.Map<List<Procedure>, List<ProcedureLookupDto>>(procedures);
            return new ListResultDto<ProcedureLookupDto>(dtos);
        }

        // Optional: Implement Excel Export
        [Authorize(CoreFWPermissions.Procedures.Export)] // Add Export permission if not defined
        public async Task<IRemoteStreamContent> GetListAsExcelAsync(GetProceduresInput input)
        {
             if (_excelExportHelper == null)
            {
                 throw new UserFriendlyException("Excel export functionality is not configured.");
            }
            // 1. Get filtered list (no pagination for export)
            var entities = await _procedureRepository.GetListAsync(
                filterText: input.Filter,
                status: input.Status,
                sorting: input.Sorting ?? "Order ASC, Name ASC",
                maxResultCount: int.MaxValue, // Get all for export
                skipCount: 0
            );

            // 2. Map to Excel DTOs
            var excelDtos = ObjectMapper.Map<List<Procedure>, List<ProcedureExcelDto>>(entities);

            // If not using MappingAction, localize StatusText here:
            /*
            foreach (var dto in excelDtos)
            {
                var entityStatus = entities.FirstOrDefault(e => e.Id == dto.Id)?.Status;
                if (entityStatus.HasValue)
                {
                    dto.StatusText = _localizer[$"Enum:ProcedureStatus.{(int)entityStatus.Value}"];
                }
            }
            */

            // 3. Use helper to generate Excel file
            var fileContent = await _excelExportHelper.ExportToExcelAsync(excelDtos, "Procedures"); // Sheet name
            return fileContent;
        }

        // Add method for updating sync info if needed via API
        /*
        [Authorize(CoreFWPermissions.Procedures.Sync)] // Define Sync permission
        public async Task UpdateSyncInfoAsync(Guid id, UpdateProcedureSyncInfoDto syncInfo)
        {
            var entity = await _procedureRepository.GetAsync(id);
            entity = await _procedureManager.UpdateSyncInfoAsync(
                entity,
                syncInfo.LastSyncedDate,
                syncInfo.SyncRecordId,
                syncInfo.SyncRecordCode
            );
            await _procedureRepository.UpdateAsync(entity, autoSave: true);
        }
        */
    }
    ```

## 3. Cập nhật `CoreFWApplicationModule.cs`

-   **Vị trí:** `src/Aqt.CoreFW.Application/CoreFWApplicationModule.cs`
-   **Hành động:** Đảm bảo rằng project `Aqt.CoreFW.Application` có tham chiếu đến `Aqt.CoreFW.Application.Contracts`. Cập nhật phương thức `ConfigureServices` để đăng ký AutoMapper profile mới.
-   **Nội dung cần thêm/cập nhật trong `ConfigureServices`:**
    ```csharp
    Configure<AbpAutoMapperOptions>(options =>
    {
        // Add all profiles in this assembly
        // options.AddMaps<CoreFWApplicationModule>();

        // Hoặc thêm từng profile cụ thể
        options.AddProfile<ProcedureApplicationAutoMapperProfile>(validate: true); // Thêm profile của Procedure
        // options.AddProfile<DataImportantApplicationAutoMapperProfile>(validate: true);
        // ... các profile khác ...
    });
    ```

## 4. Lưu ý

*   **Dependency Injection:** `ProcedureAppService` inject `IProcedureRepository`, `ProcedureManager`, `IStringLocalizer`, và (tùy chọn) `IAbpExcelExportHelper`.
*   **Permissions:** Các phương thức CRUD và phương thức tùy chỉnh được bảo vệ bằng các permission đã định nghĩa trong `CoreFWPermissions.Procedures`.
*   **Mapping:** AutoMapper được sử dụng để chuyển đổi giữa Entity và DTO. `ProcedureDto` không yêu cầu load dữ liệu liên quan, nên việc mapping đơn giản hơn.
*   **Domain Service Usage:** Logic tạo (`CreateAsync`) và cập nhật (`UpdateAsync`) phức tạp, đặc biệt là việc kiểm tra tính duy nhất của `Code`, được ủy thác cho `ProcedureManager`.
*   **Repository Usage:** AppService sử dụng `IProcedureRepository` cho các truy vấn.
*   **Error Handling:** Sử dụng `UserFriendlyException` hoặc `BusinessException` (từ Domain Service) để thông báo lỗi.
*   **Excel Export:** Việc triển khai `GetListAsExcelAsync` là tùy chọn. Việc địa phương hóa `StatusText` có thể thực hiện trong Mapping Action hoặc trực tiếp trong AppService.
*   **Lookup Optimization:** `GetLookupAsync` sử dụng phương thức `GetLookupAsync` từ repository (được thêm ở kế hoạch 2) để lấy danh sách các thực thể đang hoạt động và sắp xếp theo `Order`, `Name`.
*   **Code Immutability:** Logic trong `UpdateAsync` kiểm tra và ngăn chặn việc thay đổi `Code` sau khi tạo.
*   **Sync Info Update:** Đã thêm ví dụ (comment) về cách triển khai phương thức cập nhật thông tin đồng bộ qua API nếu cần, bao gồm cả việc định nghĩa quyền `Sync`.