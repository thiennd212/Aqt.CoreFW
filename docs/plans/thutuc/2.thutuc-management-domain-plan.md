# Kế hoạch chi tiết: Tầng Domain (`Aqt.CoreFW.Domain`) - Quản lý Thủ tục hành chính (Procedure)

Phần này mô tả các thành phần cần tạo hoặc cập nhật trong tầng `Aqt.CoreFW.Domain` để hỗ trợ chức năng quản lý Thủ tục hành chính (Procedure). Kế hoạch này dựa trên yêu cầu trong `docs/srs/thutuc-srs.md`, kế hoạch tổng thể `0.thutuc-plan-v1.md` và kế hoạch tầng Domain.Shared `1.thutuc-management-domain-shared-plan.md`.

## 1. Entity (`Procedure.cs`)

**Nguyên tắc thiết kế Entity (DDD):**

*   **Đóng gói (Encapsulation):** Sử dụng `private set` cho các thuộc tính. `Code` không thay đổi sau khi tạo.
*   **Validation tập trung:** Tạo các phương thức `private` hoặc `internal` chứa logic validation (`Check.*`) sử dụng hằng số từ `ProcedureConsts`.
*   **Trạng thái hợp lệ (Valid State):** Constructor chính (`internal`) nhận tham số bắt buộc, gọi phương thức validation nội bộ để đảm bảo entity hợp lệ khi khởi tạo. Constructor `protected` dùng cho ORM.
*   **Hành vi (Behavior):** Định nghĩa phương thức `public` để thay đổi trạng thái có kiểm soát (ví dụ: `SetName`, `Activate`, `UpdateSyncInfo`).
*   **Kế thừa:** Sử dụng `FullAuditedAggregateRoot<Guid>` theo kế hoạch tổng thể, phù hợp cho entity độc lập và quản lý audit/soft delete.
*   **Thông tin đồng bộ:** Các trường `LastSyncedDate`, `SyncRecordId`, `SyncRecordCode` là nullable và có thể được cập nhật qua một phương thức riêng (`UpdateSyncInfo`).

**Cấu trúc `Procedure.cs`:**

-   **Vị trí:** `src/Aqt.CoreFW.Domain/Procedures/Entities/Procedure.cs` (Tạo thư mục `Procedures/Entities` nếu chưa có)
-   **Nội dung:**
    ```csharp
    using System;
    using Aqt.CoreFW.Procedures; // Namespace chứa Consts và Enum từ Domain.Shared
    using JetBrains.Annotations;
    using Volo.Abp;
    using Volo.Abp.Domain.Entities.Auditing;

    namespace Aqt.CoreFW.Domain.Procedures.Entities; // Namespace cụ thể cho Entity

    /// <summary>
    /// Represents an administrative procedure.
    /// Inherits from FullAuditedAggregateRoot for audit logging and soft delete.
    /// </summary>
    public class Procedure : FullAuditedAggregateRoot<Guid>
    {
        /// <summary>
        /// Unique code for the procedure.
        /// Cannot be changed after creation.
        /// </summary>
        [NotNull]
        public virtual string Code { get; private set; }

        /// <summary>
        /// Name of the procedure.
        /// </summary>
        [NotNull]
        public virtual string Name { get; private set; }

        /// <summary>
        /// Status of the procedure (Active/Inactive).
        /// </summary>
        public virtual ProcedureStatus Status { get; private set; }

        /// <summary>
        /// Display or processing order.
        /// </summary>
        public virtual int Order { get; private set; }

        /// <summary>
        /// Optional description.
        /// </summary>
        [CanBeNull]
        public virtual string? Description { get; private set; }

        /// <summary>
        /// Date when this record was last synchronized with an external source.
        /// </summary>
        [CanBeNull]
        public virtual DateTime? LastSyncedDate { get; private set; }

        /// <summary>
        /// ID of the corresponding record in the external synchronization source.
        /// </summary>
        [CanBeNull]
        public virtual Guid? SyncRecordId { get; private set; }

        /// <summary>
        /// Code or identifier of the corresponding record in the external synchronization source.
        /// </summary>
        [CanBeNull]
        public virtual string? SyncRecordCode { get; private set; }

        /// <summary>
        /// Protected constructor for ORM frameworks.
        /// </summary>
        protected Procedure()
        {
            /* For ORM */
            Code = string.Empty; // Initialize with valid default
            Name = string.Empty; // Initialize with valid default
        }

        /// <summary>
        /// Creates a new instance of the <see cref="Procedure"/> class.
        /// Ensures required fields are provided and validates initial state.
        /// Use ProcedureManager to create instances.
        /// </summary>
        /// <param name="id">The unique identifier.</param>
        /// <param name="code">The unique code.</param> // Manager validates uniqueness
        /// <param name="name">The name.</param>
        /// <param name="order">The display order.</param>
        /// <param name="description">Optional description.</param>
        /// <param name="status">The status.</param>
        internal Procedure( // Constructor internal để buộc tạo qua ProcedureManager
            Guid id,
            [NotNull] string code,
            [NotNull] string name,
            int order = 0,
            [CanBeNull] string? description = null,
            ProcedureStatus status = ProcedureStatus.Active)
            : base(id)
        {
            // Set Code directly, only once, validated by ProcedureManager
            SetCodeInternal(code);

            // Set other properties via internal setters for validation
            SetNameInternal(name);
            SetOrderInternal(order);
            SetDescriptionInternal(description);
            Status = status; // Assign enum directly

            // Sync fields are initially null
            LastSyncedDate = null;
            SyncRecordId = null;
            SyncRecordCode = null;
        }

        // --- Internal setters with validation ---

        private void SetCodeInternal([NotNull] string code)
        {
            Check.NotNullOrWhiteSpace(code, nameof(code), ProcedureConsts.MaxCodeLength);
            Code = code;
        }

        private void SetNameInternal([NotNull] string name)
        {
            Check.NotNullOrWhiteSpace(name, nameof(name), ProcedureConsts.MaxNameLength);
            Name = name;
        }

         private void SetOrderInternal(int order)
        {
            // Add validation for Order if needed (e.g., non-negative)
            Order = order;
        }

        private void SetDescriptionInternal([CanBeNull] string? description)
        {
            Check.Length(description, nameof(description), ProcedureConsts.MaxDescriptionLength);
            Description = description;
        }

        private void SetSyncRecordCodeInternal([CanBeNull] string? syncRecordCode)
        {
            Check.Length(syncRecordCode, nameof(syncRecordCode), ProcedureConsts.MaxSyncRecordCodeLength);
            SyncRecordCode = syncRecordCode;
        }

        // --- Public methods to change state ---

        /// <summary>
        /// Changes the name of the procedure.
        /// </summary>
        public Procedure SetName([NotNull] string name)
        {
            SetNameInternal(name);
            return this;
        }

         /// <summary>
        /// Changes the display/processing order.
        /// </summary>
        public Procedure SetOrder(int order)
        {
            SetOrderInternal(order);
            return this;
        }

        /// <summary>
        /// Changes the description.
        /// </summary>
        public Procedure SetDescription([CanBeNull] string? description)
        {
            SetDescriptionInternal(description);
            return this;
        }

        /// <summary>
        /// Sets the procedure status to Active.
        /// </summary>
        public Procedure Activate()
        {
            Status = ProcedureStatus.Active;
            return this;
        }

        /// <summary>
        /// Sets the procedure status to Inactive.
        /// </summary>
        public Procedure Deactivate()
        {
            Status = ProcedureStatus.Inactive;
            return this;
        }

        /// <summary>
        /// Updates synchronization information.
        /// Typically called by a dedicated synchronization process.
        /// </summary>
        public Procedure UpdateSyncInfo(DateTime? lastSyncedDate, Guid? syncRecordId, [CanBeNull] string? syncRecordCode)
        {
            LastSyncedDate = lastSyncedDate;
            SyncRecordId = syncRecordId;
            SetSyncRecordCodeInternal(syncRecordCode); // Use internal setter for validation
            return this;
        }

        // Note: No public SetCode method.
    }
    ```

## 2. Repository Interface (`IProcedureRepository.cs`)

-   **Vị trí:** Tạo thư mục `src/Aqt.CoreFW.Domain/Procedures` (nếu chưa có)
-   **Tệp:** Tạo file `IProcedureRepository.cs`
-   **Nội dung:**
    ```csharp
    using System;
    using System.Collections.Generic;
    using System.Threading;
    using System.Threading.Tasks;
    using Aqt.CoreFW.Procedures; // Namespace chứa Enum
    using Aqt.CoreFW.Domain.Procedures.Entities; // Namespace chứa Entity
    using JetBrains.Annotations;
    using Volo.Abp.Domain.Repositories;

    namespace Aqt.CoreFW.Domain.Procedures;

    /// <summary>
    /// Defines the repository interface for the Procedure entity.
    /// </summary>
    public interface IProcedureRepository : IRepository<Procedure, Guid> // Kế thừa IRepository cơ bản
    {
        /// <summary>
        /// Finds a Procedure by its unique code.
        /// </summary>
        /// <param name="code">The code to search for.</param>
        /// <param name="includeDetails">Include details (if any navigation properties are defined).</param>
        /// <param name="cancellationToken">Cancellation token.</param>
        /// <returns>The found Procedure or null.</returns>
        Task<Procedure?> FindByCodeAsync(
            [NotNull] string code,
            bool includeDetails = false,
            CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets a list of Procedures based on filtering criteria.
        /// </summary>
        /// <param name="filterText">Text to search in Code or Name.</param>
        /// <param name="code">Filter by exact code.</param>
        /// <param name="name">Filter by name containing text.</param>
        /// <param name="status">Filter by status.</param>
        /// <param name="sorting">Sorting expression (e.g., "Order ASC, Name ASC").</param>
        /// <param name="maxResultCount">Maximum number of results to return.</param>
        /// <param name="skipCount">Number of results to skip (for pagination).</param>
        /// <param name="cancellationToken">Cancellation token.</param>
        /// <returns>A list of Procedures.</returns>
        Task<List<Procedure>> GetListAsync(
            string? filterText = null,
            string? code = null,
            string? name = null,
            ProcedureStatus? status = null,
            string? sorting = null,
            int maxResultCount = int.MaxValue,
            int skipCount = 0,
            CancellationToken cancellationToken = default);

        /// <summary>
        /// Gets the total count of Procedures based on filtering criteria.
        /// </summary>
        /// <param name="filterText">Text to search in Code or Name.</param>
        /// <param name="code">Filter by exact code.</param>
        /// <param name="name">Filter by name containing text.</param>
        /// <param name="status">Filter by status.</param>
        /// <param name="cancellationToken">Cancellation token.</param>
        /// <returns>The total count.</returns>
        Task<long> GetCountAsync(
            string? filterText = null,
            string? code = null,
            string? name = null,
            ProcedureStatus? status = null,
            CancellationToken cancellationToken = default);

        /// <summary>
        /// Checks if a Procedure with the given code already exists.
        /// </summary>
        /// <param name="code">The code to check.</param>
        /// <param name="excludeId">Optional: Exclude this ID from the check (used during update).</param>
        /// <param name="cancellationToken">Cancellation token.</param>
        /// <returns>True if the code exists, false otherwise.</returns>
        Task<bool> CodeExistsAsync(
            [NotNull] string code,
            Guid? excludeId = null,
            CancellationToken cancellationToken = default);

        /// <summary>
        /// GetLookupAsync
        /// </summary>
        Task<List<Procedure>> GetLookupAsync(
            bool onlyActive = true,
            string? sorting = "Order ASC, Name ASC",
            CancellationToken cancellationToken = default);
    }
    ```

## 3. Domain Service (`ProcedureManager.cs`)

**Trách nhiệm:**

*   Thực thi các quy tắc nghiệp vụ phức tạp liên quan đến Procedures.
*   Đảm bảo tính nhất quán khi tạo (`CreateAsync`) và cập nhật (`UpdateAsync`, `UpdateSyncInfoAsync`) Procedures.
*   Kiểm tra tính duy nhất của `Code` trên toàn hệ thống.
*   Tương tác với `IProcedureRepository`.

**Cấu trúc `ProcedureManager.cs`:**

-   **Vị trí:** `src/Aqt.CoreFW.Domain/Procedures/`
-   **Tệp:** Tạo file `ProcedureManager.cs`
-   **Nội dung:**
    ```csharp
    using System;
    using System.Threading.Tasks;
    using Aqt.CoreFW.Procedures; // Namespaces cần thiết
    using Aqt.CoreFW.Domain.Procedures.Entities;
    using JetBrains.Annotations;
    using Volo.Abp;
    using Volo.Abp.Domain.Services;
    using Volo.Abp.Guids;
    // using Volo.Abp.Users; // Inject nếu cần

    namespace Aqt.CoreFW.Domain.Procedures;

    /// <summary>
    /// Domain service responsible for managing Procedure entities.
    /// </summary>
    public class ProcedureManager : DomainService
    {
        private readonly IProcedureRepository _procedureRepository;
        private readonly IGuidGenerator _guidGenerator;
        // private readonly ICurrentUser _currentUser;

        public ProcedureManager(
            IProcedureRepository procedureRepository,
            IGuidGenerator guidGenerator/*,
            ICurrentUser currentUser*/)
        {
            _procedureRepository = procedureRepository;
            _guidGenerator = guidGenerator;
            // _currentUser = currentUser;
        }

        /// <summary>
        /// Creates a new Procedure entity after validating business rules.
        /// </summary>
        /// <param name="code">Unique code.</param>
        /// <param name="name">Name.</param>
        /// <param name="order">Display order.</param>
        /// <param name="description">Optional description.</param>
        /// <param name="status">Status.</param>
        /// <returns>The newly created Procedure entity.</returns>
        /// <exception cref="UserFriendlyException">Thrown if business rules are violated.</exception>
        public async Task<Procedure> CreateAsync(
            [NotNull] string code,
            [NotNull] string name,
            int order = 0,
            [CanBeNull] string? description = null,
            ProcedureStatus status = ProcedureStatus.Active)
        {
            Check.NotNullOrWhiteSpace(code, nameof(code), ProcedureConsts.MaxCodeLength);
            Check.NotNullOrWhiteSpace(name, nameof(name), ProcedureConsts.MaxNameLength);
            Check.Length(description, nameof(description), ProcedureConsts.MaxDescriptionLength);

            // Validate Code uniqueness (globally)
            await ValidateCodeUniquenessAsync(code);

            var procedure = new Procedure(
                _guidGenerator.Create(),
                code,
                name,
                order,
                description,
                status
            );

            // Application Service will call Repository.InsertAsync
            return procedure;
        }

        /// <summary>
        /// Updates an existing Procedure entity after validating business rules.
        /// Note: Code cannot be changed.
        /// </summary>
        /// <param name="procedure">The entity to update.</param>
        /// <param name="name">New name.</param>
        /// <param name="order">New display order.</param>
        /// <param name="description">New optional description.</param>
        /// <param name="status">New status.</param>
        /// <returns>The updated Procedure entity.</returns>
        /// <exception cref="UserFriendlyException">Thrown if business rules are violated.</exception>
        public Task<Procedure> UpdateAsync(
            [NotNull] Procedure procedure,
            [NotNull] string name,
            int order,
            [CanBeNull] string? description,
            ProcedureStatus status)
        {
            Check.NotNull(procedure, nameof(procedure));
            Check.NotNullOrWhiteSpace(name, nameof(name), ProcedureConsts.MaxNameLength);
            Check.Length(description, nameof(description), ProcedureConsts.MaxDescriptionLength);

            // Update properties using entity methods
            procedure.SetName(name);
            procedure.SetOrder(order);
            procedure.SetDescription(description);

            if (status == ProcedureStatus.Active) procedure.Activate();
            else procedure.Deactivate();

            // Application Service will call Repository.UpdateAsync
            return Task.FromResult(procedure); // No async validation needed here for standard updates
        }

        /// <summary>
        /// Updates synchronization information for a Procedure entity.
        /// </summary>
        /// <param name="procedure">The entity to update.</param>
        /// <param name="lastSyncedDate">New last synced date.</param>
        /// <param name="syncRecordId">New sync record ID.</param>
        /// <param name="syncRecordCode">New sync record code.</param>
        /// <returns>The updated Procedure entity.</returns>
        public Task<Procedure> UpdateSyncInfoAsync(
             [NotNull] Procedure procedure,
             DateTime? lastSyncedDate,
             Guid? syncRecordId,
             [CanBeNull] string? syncRecordCode)
        {
            Check.NotNull(procedure, nameof(procedure));
            Check.Length(syncRecordCode, nameof(syncRecordCode), ProcedureConsts.MaxSyncRecordCodeLength);

            procedure.UpdateSyncInfo(lastSyncedDate, syncRecordId, syncRecordCode);

            // Application Service will call Repository.UpdateAsync
             return Task.FromResult(procedure);
        }

        /// <summary>
        /// Helper method to validate code uniqueness (globally).
        /// </summary>
        private async Task ValidateCodeUniquenessAsync([NotNull] string code, Guid? excludeId = null)
        {
             if (await _procedureRepository.CodeExistsAsync(code, excludeId))
            {
                throw new UserFriendlyException(L["ProcedureCodeAlreadyExists", code]);
                // Or use BusinessException: throw new BusinessException(CoreFWDomainErrorCodes.ProcedureCodeAlreadyExists).WithData("code", code);
            }
        }
    }
    ```

## 4. Cập nhật `CoreFWDomainModule.cs`

-   **Vị trí:** `src/Aqt.CoreFW.Domain/CoreFWDomainModule.cs`
-   **Hành động:** Không cần thay đổi. ABP tự động đăng ký `ProcedureManager` và `IProcedureRepository` (nếu được triển khai ở tầng EF Core) thông qua cơ chế quét và đăng ký tự động.

## 5. Lưu ý

*   **Tính duy nhất của `Code`:** Kế hoạch này tuân thủ yêu cầu `Code` duy nhất toàn hệ thống (theo giả định trong kế hoạch tổng thể). Điều này được phản ánh trong `IProcedureRepository` và logic của `ProcedureManager`.
*   **Aggregate Root:** Việc chọn `FullAuditedAggregateRoot` được giữ lại theo kế hoạch tổng thể. Nó phù hợp cho một thực thể độc lập như `Procedure`.
*   **Repository Dependency:** `ProcedureManager` chỉ phụ thuộc vào `IProcedureRepository` và các dịch vụ cơ bản của ABP.
*   **Error Handling:** Sử dụng `UserFriendlyException` với localization key hoặc `BusinessException` với Error Code đã định nghĩa trong `CoreFWDomainErrorCodes.Procedures.cs`.
*   **Namespace:** Đảm bảo sử dụng đúng namespace cho các class và interface.
*   **Thông tin đồng bộ:** Có phương thức `UpdateSyncInfoAsync` riêng trong Manager và `UpdateSyncInfo` trong Entity để xử lý việc cập nhật các trường liên quan đến đồng bộ dữ liệu. Việc gọi phương thức này thường nằm trong một quy trình đồng bộ riêng biệt, không phải là một phần của CRUD thông thường từ giao diện người dùng. 