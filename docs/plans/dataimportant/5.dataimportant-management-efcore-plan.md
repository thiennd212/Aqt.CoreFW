# Kế hoạch chi tiết: Tầng EntityFrameworkCore (`Aqt.CoreFW.EntityFrameworkCore`) - Quản lý Danh mục Dữ liệu Quan trọng (DataImportant Management)

Phần này mô tả các thành phần cần tạo hoặc cập nhật trong tầng `Aqt.CoreFW.EntityFrameworkCore` cho module Quản lý Danh mục Dữ liệu Quan trọng (DataImportant).

## 1. DbContext

-   **Vị trí:** Cập nhật file `src/Aqt.CoreFW.EntityFrameworkCore/EntityFrameworkCore/CoreFWDbContext.cs`
-   **Nội dung cần thêm:**
    ```csharp
    using Aqt.CoreFW.Domain.DataImportants.Entities; // Thêm using cho DataImportant Entity
    using Microsoft.EntityFrameworkCore;
    using System.Reflection;
    // ... other usings ...

    public class CoreFWDbContext : AbpDbContext<CoreFWDbContext>, /* ... các interface khác ... */
    {
        // ... các DbSet khác (DataGroup, DataCore, Province, etc.) ...
        public DbSet<DataImportant> DataImportants { get; set; } // Thêm DbSet cho DataImportant


        public CoreFWDbContext(DbContextOptions<CoreFWDbContext> options)
            : base(options)
        {
        }

        protected override void OnModelCreating(ModelBuilder builder)
        {
            base.OnModelCreating(builder);

            // Cấu hình các module khác của ABP...
            // ...

            // Áp dụng tất cả cấu hình entity trong assembly này
            builder.ApplyConfigurationsFromAssembly(Assembly.GetExecutingAssembly());
        }
    }
    ```

## 2. Entity Configuration (`DataImportantConfiguration.cs`)

-   **Vị trí:** Tạo thư mục `src/Aqt.CoreFW.EntityFrameworkCore/EntityTypeConfigurations/DataImportants` (Tạo thư mục nếu chưa có)
-   **Tệp:** Tạo file `DataImportantConfiguration.cs`
-   **Nội dung:**
    ```csharp
    using Aqt.CoreFW.Domain.DataImportants.Entities; // DataImportant Entity
    using Aqt.CoreFW.Domain.DataGroups.Entities; // DataGroup Entity for FK relation
    using Aqt.CoreFW.Domain.Shared; // Namespace chứa CoreFWConsts
    using Aqt.CoreFW.DataImportants; // Namespace chứa DataImportantConsts và DataImportantStatus enum
    using Microsoft.EntityFrameworkCore;
    using Microsoft.EntityFrameworkCore.Metadata.Builders;
    using Volo.Abp.EntityFrameworkCore.Modeling;

    namespace Aqt.CoreFW.EntityFrameworkCore.EntityTypeConfigurations.DataImportants; // Namespace Configuration

    /// <summary>
    /// Configures the database mapping for the <see cref="DataImportant"/> entity.
    /// </summary>
    public class DataImportantConfiguration : IEntityTypeConfiguration<DataImportant>
    {
        public void Configure(EntityTypeBuilder<DataImportant> builder)
        {
            // Sử dụng DbTablePrefix và DbSchema từ CoreFWConsts
            builder.ToTable(CoreFWConsts.DbTablePrefix + "DataImportants", CoreFWConsts.DbSchema);

            builder.ConfigureByConvention(); // Áp dụng các quy ước chuẩn của ABP

            builder.HasKey(x => x.Id);

            // --- Property Configurations ---
            builder.Property(x => x.Code)
                .IsRequired()
                .HasMaxLength(DataImportantConsts.MaxCodeLength)
                .HasColumnName(nameof(DataImportant.Code));

            builder.Property(x => x.Name)
                .IsRequired()
                .HasMaxLength(DataImportantConsts.MaxNameLength)
                .HasColumnName(nameof(DataImportant.Name));

            builder.Property(x => x.Status)
                .IsRequired()
                .HasColumnName(nameof(DataImportant.Status))
                .HasConversion<byte>(); // Map enum sang byte

            builder.Property(x => x.Order)
                .IsRequired()
                .HasColumnName(nameof(DataImportant.Order));

            builder.Property(x => x.Description)
                .HasMaxLength(DataImportantConsts.MaxDescriptionLength)
                .HasColumnName(nameof(DataImportant.Description));

            // DataGroupId là Guid bắt buộc
            builder.Property(x => x.DataGroupId)
                .IsRequired()
                .HasColumnName(nameof(DataImportant.DataGroupId));

            // --- Foreign Keys ---
            builder.HasOne<DataGroup>() // Không cần chỉ định navigation property 'DataGroup' nếu không có trong Entity
                   .WithMany() // Một DataGroup có thể có nhiều DataImportant
                   .HasForeignKey(x => x.DataGroupId)
                   .IsRequired() // Đảm bảo FK là bắt buộc
                   .OnDelete(DeleteBehavior.Restrict); // Quan trọng: Ngăn chặn việc xóa DataGroup nếu còn DataImportant tham chiếu

            // --- Indexes ---

            // Index cho Code (Unique theo DataGroupId)
            builder.HasIndex(x => new { x.DataGroupId, x.Code })
                   .IsUnique() // Đảm bảo Code là duy nhất trong phạm vi DataGroupId
                   .HasDatabaseName($"IX_{CoreFWConsts.DbTablePrefix}DataImportants_DataGroupId_Code");

            builder.HasIndex(x => x.Name)
                   .HasDatabaseName($"IX_{CoreFWConsts.DbTablePrefix}DataImportants_Name");

            builder.HasIndex(x => x.Status)
                   .HasDatabaseName($"IX_{CoreFWConsts.DbTablePrefix}DataImportants_Status");

            // Index trên DataGroupId (đã có trong index kết hợp bên trên, nhưng thêm riêng cũng không sao)
            builder.HasIndex(x => x.DataGroupId)
                   .HasDatabaseName($"IX_{CoreFWConsts.DbTablePrefix}DataImportants_DataGroupId");

            // Index kết hợp cho sắp xếp/lọc phổ biến trong cùng nhóm
            builder.HasIndex(x => new { x.DataGroupId, x.Status, x.Order, x.Name })
                  .HasDatabaseName($"IX_{CoreFWConsts.DbTablePrefix}DataImportants_DataGroupId_Status_Order_Name");
        }
    }
    ```

## 3. Repository Implementation (`DataImportantRepository.cs`)

-   **Vị trí:** Tạo thư mục `src/Aqt.CoreFW.EntityFrameworkCore/Repositories/DataImportants` (Tạo thư mục nếu chưa có)
-   **Tệp:** Tạo file `DataImportantRepository.cs` bên trong thư mục trên
-   **Nội dung:**
    ```csharp
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Linq.Dynamic.Core;
    using System.Threading;
    using System.Threading.Tasks;
    using Aqt.CoreFW.Domain.DataImportants; // IDataImportantRepository
    using Aqt.CoreFW.Domain.DataImportants.Entities; // DataImportant Entity
    using Aqt.CoreFW.EntityFrameworkCore; // CoreFWDbContext, EfCoreRepository
    using Aqt.CoreFW.DataImportants; // DataImportantStatus enum
    using JetBrains.Annotations;
    using Microsoft.EntityFrameworkCore;
    using Volo.Abp.Domain.Repositories.EntityFrameworkCore;
    using Volo.Abp.EntityFrameworkCore;

    namespace Aqt.CoreFW.EntityFrameworkCore.Repositories.DataImportants;

    public class DataImportantRepository :
        EfCoreRepository<CoreFWDbContext, DataImportant, Guid>,
        IDataImportantRepository
    {
        public DataImportantRepository(IDbContextProvider<CoreFWDbContext> dbContextProvider)
            : base(dbContextProvider)
        {
        }

        // Implementation requires DataGroupId because Code is unique per group
        public async Task<DataImportant?> FindByCodeAsync(
            [NotNull] string code,
            Guid dataGroupId,
            bool includeDetails = false, // Typically false if no navigation props needed
            CancellationToken cancellationToken = default)
        {
            var dbSet = await GetDbSetAsync();
            var query = dbSet.AsNoTracking(); // Use AsNoTracking for read-only queries

            // If includeDetails is true and navigation properties exist, add .Include() here
            // query = includeDetails ? query.Include(di => di.DataGroup) : query;

            return await query.FirstOrDefaultAsync(
                di => di.DataGroupId == dataGroupId && di.Code == code,
                GetCancellationToken(cancellationToken));
        }

        // Implementation requires DataGroupId
        public async Task<bool> CodeExistsAsync(
            [NotNull] string code,
            Guid dataGroupId,
            Guid? excludeId = null,
            CancellationToken cancellationToken = default)
        {
            var dbSet = await GetDbSetAsync();
            var query = dbSet.AsNoTracking()
                             .Where(di => di.DataGroupId == dataGroupId && di.Code == code);

            if (excludeId.HasValue)
            {
                query = query.Where(di => di.Id != excludeId.Value);
            }

            return await query.AnyAsync(GetCancellationToken(cancellationToken));
        }

        public async Task<List<DataImportant>> GetListAsync(
            string? filterText = null,
            string? code = null,
            string? name = null,
            DataImportantStatus? status = null,
            Guid? dataGroupId = null,
            string? sorting = null,
            int maxResultCount = int.MaxValue,
            int skipCount = 0,
            CancellationToken cancellationToken = default)
        {
            var query = await GetListQueryInternalAsync(filterText, code, name, status, dataGroupId);

            query = query.OrderBy(sorting.IsNullOrWhiteSpace() ?
                $"{nameof(DataImportant.Order)} asc, {nameof(DataImportant.Name)} asc" // Default sort
                : sorting);

            return await query.PageBy(skipCount, maxResultCount)
                              .ToListAsync(GetCancellationToken(cancellationToken));
        }

        public async Task<long> GetCountAsync(
            string? filterText = null,
            string? code = null,
            string? name = null,
            DataImportantStatus? status = null,
            Guid? dataGroupId = null,
            CancellationToken cancellationToken = default)
        {
            var query = await GetListQueryInternalAsync(filterText, code, name, status, dataGroupId);
            return await query.LongCountAsync(GetCancellationToken(cancellationToken));
        }

        public async Task<List<DataImportant>> GetListByDataGroupIdAsync(
            Guid dataGroupId,
            bool onlyActive = true,
            string? sorting = null, // Default handled below
            CancellationToken cancellationToken = default)
        {
            var dbSet = await GetDbSetAsync();
            var query = dbSet.AsNoTracking().Where(di => di.DataGroupId == dataGroupId);

            if (onlyActive)
            {
                query = query.Where(di => di.Status == DataImportantStatus.Active);
            }

            query = query.OrderBy(sorting.IsNullOrWhiteSpace() ?
                 $"{nameof(DataImportant.Order)} asc, {nameof(DataImportant.Name)} asc" // Sensible default for lookups
                 : sorting);

            // No pagination for typical lookup lists
            return await query.ToListAsync(GetCancellationToken(cancellationToken));
        }

        // --- Private Helper Method ---

        private async Task<IQueryable<DataImportant>> GetListQueryInternalAsync(
            string? filterText = null,
            string? code = null,
            string? name = null,
            DataImportantStatus? status = null,
            Guid? dataGroupId = null)
        {
            var dbSet = await GetDbSetAsync();
            return dbSet.AsNoTracking()
                // Combined filter for Code or Name
                .WhereIf(!filterText.IsNullOrWhiteSpace(), di =>
                    (di.Code != null && di.Code.Contains(filterText!)) ||
                    (di.Name != null && di.Name.Contains(filterText!)))
                // Specific filters
                .WhereIf(!code.IsNullOrWhiteSpace(), di => di.Code == code)
                .WhereIf(!name.IsNullOrWhiteSpace(), di => di.Name != null && di.Name.Contains(name))
                .WhereIf(status.HasValue, di => di.Status == status!.Value)
                .WhereIf(dataGroupId.HasValue, di => di.DataGroupId == dataGroupId!.Value);
        }
    }
    ```

## 4. Cập nhật `CoreFWDbContextModelCreatingExtensions.cs` (Không bắt buộc nếu dùng `ApplyConfigurationsFromAssembly`)

-   **Vị trí:** `src/Aqt.CoreFW.EntityFrameworkCore/EntityFrameworkCore/CoreFWDbContextModelCreatingExtensions.cs`
-   **Hành động:** Nếu bạn **không** sử dụng `builder.ApplyConfigurationsFromAssembly(Assembly.GetExecutingAssembly());` trong `CoreFWDbContext.OnModelCreating`, bạn cần gọi thủ công phương thức cấu hình cho `DataImportant` tại đây.
    ```csharp
    public static void ConfigureCoreFW(this ModelBuilder builder)
    {
        Check.NotNull(builder, nameof(builder));

        // ... Cấu hình cho các entity khác (Province, District, Commune, Rank, DataGroup, DataCore) ...

        // Cấu hình cho DataImportant
        builder.ApplyConfiguration(new Aqt.CoreFW.EntityFrameworkCore.EntityTypeConfigurations.DataImportants.DataImportantConfiguration());

        // ... các cấu hình khác ...
    }
    ```
    **Khuyến nghị:** Sử dụng `ApplyConfigurationsFromAssembly` để tự động áp dụng tất cả cấu hình.

## 5. Database Migrations

-   **Hành động:**
    1.  **Thêm Migration:** Mở Package Manager Console (PMC) hoặc terminal, chọn project `Aqt.CoreFW.EntityFrameworkCore` làm project mặc định.
        ```bash
        dotnet ef migrations add Added_DataImportant_Module
        ```
        *(Sử dụng tên migration mô tả, ví dụ: `Added_DataImportant_Module`, `Added_DataImportants_Table`)*
    2.  **Kiểm tra Migration:** Mở file migration mới được tạo trong thư mục `Migrations` của project `Aqt.CoreFW.EntityFrameworkCore` để xem lại các thay đổi SQL được tạo ra (tạo bảng `DataImportants`, thêm cột, khóa ngoại, **index unique kết hợp**).
    3.  **Cập nhật Database:**
        ```bash
        dotnet ef database update
        ```

## 6. Lưu ý

*   **Namespace:** Đảm bảo các namespace là chính xác cho Entity, Enum, Constants, Configuration, Repository và DbContext.
*   **Code Uniqueness:** Cấu hình và logic Repository đã được điều chỉnh để đảm bảo `DataImportant.Code` là **duy nhất trong phạm vi `DataGroupId`**. Điều này thể hiện qua `HasIndex(...).IsUnique()` kết hợp và các phương thức `FindByCodeAsync`, `CodeExistsAsync` yêu cầu `dataGroupId`.
*   **Foreign Key Constraint:** Đã cấu hình `OnDelete(DeleteBehavior.Restrict)` cho khóa ngoại `DataGroupId` để ngăn xóa `DataGroup` nếu còn `DataImportant` liên quan.
*   **Indexes:** Đã thêm các index cần thiết, bao gồm index unique kết hợp và các index khác để tối ưu lọc/sắp xếp.
*   **Repository Implementation:** Repository triển khai các phương thức trong `IDataImportantRepository`, sử dụng LINQ và `IQueryable`. Logic đã được điều chỉnh để phù hợp với ràng buộc unique theo `DataGroupId`.
*   **Raw SQL:** Tránh sử dụng Raw SQL.
*   **Migrations:** Luôn tạo và kiểm tra migration cẩn thận, đặc biệt là cấu trúc index unique, trước khi cập nhật database.
