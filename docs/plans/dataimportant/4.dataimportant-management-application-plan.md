# Kế hoạch chi tiết: Tầng Application (`Aqt.CoreFW.Application`) - Quản lý Danh mục Dữ liệu Quan trọng (DataImportant Management)

Phần này mô tả các thành phần cần tạo hoặc cập nhật trong tầng `Aqt.CoreFW.Application` cho module Quản lý Danh mục Dữ liệu Quan trọng (DataImportant).

## 1. Mapping Logic

### 1.1. Mapping Action for Excel Export (`DataImportantToExcelMappingAction`)

-   **Mục đích:** Xử lý logic mapping tùy chỉnh khi chuyển đổi từ `DataImportant` (Entity) sang `DataImportantExcelDto`, bao gồm địa phương hóa `Status`, và lấy thông tin `DataGroupCode`, `DataGroupName`.
-   **Vị trí:** Tạo thư mục `src/Aqt.CoreFW.Application/DataImportants` (nếu chưa có)
-   **Tệp:** Tạo file `DataImportantToExcelMappingAction.cs` (Nếu có chức năng Export Excel)
-   **Nội dung:**
    ```csharp
    using System.Threading.Tasks;
    using Aqt.CoreFW.Application.Contracts.DataImportants.Dtos; // DataImportantExcelDto
    using Aqt.CoreFW.Domain.DataImportants.Entities; // DataImportant Entity
    using Aqt.CoreFW.Domain.DataGroups; // IDataGroupRepository
    using Aqt.CoreFW.Domain.DataGroups.Entities;
    using Aqt.CoreFW.Localization; // CoreFWResource for L[]
    using AutoMapper;
    using Microsoft.Extensions.Localization; // Required for IStringLocalizer
    using Volo.Abp.DependencyInjection; // Required for ITransientDependency
    using Volo.Abp.Domain.Repositories;

    namespace Aqt.CoreFW.Application.DataImportants; // Namespace for DataImportant Application layer

    /// <summary>
    /// AutoMapper mapping action to handle specific logic when mapping
    /// from DataImportant entity to DataImportantExcelDto.
    /// Handles localization of the Status enum.
    /// **Best Practice:** Populate DataGroupCode/Name in the AppService *before* mapping.
    /// </summary>
    public class DataImportantToExcelMappingAction
        : IMappingAction<DataImportant, DataImportantExcelDto>, ITransientDependency
    {
        private readonly IStringLocalizer<CoreFWResource> _localizer;
        // Injecting repository here for DataGroup lookup is discouraged due to potential N+1 issues.
        // private readonly IRepository<DataGroup, Guid> _dataGroupRepository;

        public DataImportantToExcelMappingAction(
            IStringLocalizer<CoreFWResource> localizer
            /*, IRepository<DataGroup, Guid> dataGroupRepository */)
        {
            _localizer = localizer;
            // _dataGroupRepository = dataGroupRepository;
        }

        public void Process(DataImportant source, DataImportantExcelDto destination, ResolutionContext context)
        {
            // Localize the Status enum
            destination.StatusText = _localizer[$"Enum:DataImportantStatus.{(int)source.Status}"];

            // Fetching DataGroup Name/Code here leads to N+1 query issues.
            // Handle this in the AppService GetListAsExcelAsync method instead.
        }
    }
    ```
    **Lưu ý:** Tương tự DataCore, việc lấy `DataGroupCode` và `DataGroupName` trong Mapping Action có thể gây vấn đề hiệu năng. Cách tốt hơn là xử lý việc này trong `DataImportantAppService.GetListAsExcelAsync` trước khi gọi `ObjectMapper.Map`.

### 1.2. AutoMapper Profile (`DataImportantApplicationAutoMapperProfile`)

-   **Vị trí:** Tạo file `src/Aqt.CoreFW.Application/DataImportants/DataImportantApplicationAutoMapperProfile.cs`
-   **Nội dung:**
    ```csharp
    using Aqt.CoreFW.Application.Contracts.DataImportants.Dtos; // DTOs for DataImportant
    using Aqt.CoreFW.Application.Contracts.Shared.Lookups; // Lookup DTOs
    using Aqt.CoreFW.Domain.DataImportants.Entities; // DataImportant Entity
    using Aqt.CoreFW.Domain.DataGroups.Entities; // DataGroup Entity (for lookup mapping)
    using AutoMapper;

    namespace Aqt.CoreFW.Application.DataImportants; // Namespace for DataImportant Application layer

    public class DataImportantApplicationAutoMapperProfile : Profile
    {
        public DataImportantApplicationAutoMapperProfile()
        {
            // --- DataImportant Mappings ---
            CreateMap<DataImportant, DataImportantDto>()
                // Ignore DataGroupName/DataGroupCode, will be populated in AppService GetList/Get
                .ForMember(dest => dest.DataGroupName, opt => opt.Ignore())
                .ForMember(dest => dest.DataGroupCode, opt => opt.Ignore());

            // Map DTO to DTO for edit form prepopulation (optional but convenient)
            CreateMap<DataImportantDto, CreateUpdateDataImportantDto>();

            // Map Entity to Lookup DTO
            CreateMap<DataImportant, DataImportantLookupDto>();

            // Map Entity to Excel DTO (if Excel Export is implemented)
            CreateMap<DataImportant, DataImportantExcelDto>()
                .ForMember(dest => dest.StatusText, opt => opt.Ignore()) // Handled by MappingAction or AppService
                .ForMember(dest => dest.DataGroupCode, opt => opt.Ignore()) // Handled by AppService
                .ForMember(dest => dest.DataGroupName, opt => opt.Ignore()); // Handled by AppService
                // .AfterMap<DataImportantToExcelMappingAction>(); // Apply action if used and only handles localization

            // --- Shared/Lookup Mappings (ensure DataGroup profile exists) ---
            // CreateMap<DataGroup, DataGroupLookupDto>(); // Should exist in DataGroup profile

            // No direct mapping from CreateUpdateDataImportantDto to DataImportant entity
            // Create/Update operations use DTO data with DataImportantManager
        }
    }
    ```

## 2. AppService Implementation (`DataImportantAppService`)

-   **Vị trí:** Tạo file `src/Aqt.CoreFW.Application/DataImportants/DataImportantAppService.cs`
-   **Nội dung:**
    ```csharp
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Linq.Dynamic.Core; // Required for dynamic sorting
    using System.Threading.Tasks;
    using Aqt.CoreFW.Application.Contracts.DataImportants; // Contracts namespace
    using Aqt.CoreFW.Application.Contracts.DataImportants.Dtos; // DTOs namespace
    using Aqt.CoreFW.Application.Contracts.Shared.Lookups; // Lookup DTO namespace
    using Aqt.CoreFW.Shared.Services; // IAbpExcelExportHelper namespace (nếu dùng)
    using Aqt.CoreFW.Domain.DataImportants; // Domain Service and Repository Interface namespace
    using Aqt.CoreFW.Domain.DataImportants.Entities; // Entity namespace
    using Aqt.CoreFW.Domain.DataGroups; // IDataGroupRepository
    using Aqt.CoreFW.Domain.DataGroups.Entities;
    using Aqt.CoreFW.Localization; // Resource namespace
    using Aqt.CoreFW.Permissions; // Permissions namespace
    using Aqt.CoreFW.DataImportants; // Enum namespace from Domain.Shared
    using Microsoft.AspNetCore.Authorization;
    using Microsoft.Extensions.Localization;
    using Volo.Abp;
    using Volo.Abp.Application.Dtos;
    using Volo.Abp.Application.Services;
    using Volo.Abp.Content; // For IRemoteStreamContent
    using Volo.Abp.Domain.Repositories;
    using Volo.Abp.ObjectMapping; // For ObjectMapper

    namespace Aqt.CoreFW.Application.DataImportants; // Application Service namespace

    [Authorize(CoreFWPermissions.DataImportants.Default)] // Default policy for read
    public class DataImportantAppService :
        CrudAppService<
            DataImportant,                 // Entity
            DataImportantDto,              // DTO Read
            Guid,                          // Primary Key
            GetDataImportantsInput,        // DTO for GetList input
            CreateUpdateDataImportantDto>, // DTO for Create/Update input
        IDataImportantAppService           // Implement the contract interface
    {
        private readonly IDataImportantRepository _dataImportantRepository;
        private readonly DataImportantManager _dataImportantManager;
        private readonly IRepository<DataGroup, Guid> _dataGroupRepository; // Basic repo for DataGroup lookup
        private readonly IStringLocalizer<CoreFWResource> _localizer;
        private readonly IAbpExcelExportHelper? _excelExportHelper; // Optional: For Excel export

        // Constructor injection
        public DataImportantAppService(
            IDataImportantRepository dataImportantRepository, // Use specific repo
            DataImportantManager dataImportantManager,
            IRepository<DataGroup, Guid> dataGroupRepository,
            IStringLocalizer<CoreFWResource> localizer,
            IAbpExcelExportHelper? excelExportHelper = null) // Optional injection
            : base(dataImportantRepository) // Pass specific repo to base
        {
            _dataImportantRepository = dataImportantRepository;
            _dataImportantManager = dataImportantManager;
            _dataGroupRepository = dataGroupRepository;
            _localizer = localizer;
            _excelExportHelper = excelExportHelper;

            // Set permission policies from Contracts
            GetPolicyName = CoreFWPermissions.DataImportants.Default;
            GetListPolicyName = CoreFWPermissions.DataImportants.Default;
            CreatePolicyName = CoreFWPermissions.DataImportants.Create;
            UpdatePolicyName = CoreFWPermissions.DataImportants.Update;
            DeletePolicyName = CoreFWPermissions.DataImportants.Delete;
        }

        // --- Overridden CRUD Methods ---

        [Authorize(CoreFWPermissions.DataImportants.Create)]
        public override async Task<DataImportantDto> CreateAsync(CreateUpdateDataImportantDto input)
        {
            // Use DataImportantManager to create, handling code uniqueness within group and DataGroup validation
            var entity = await _dataImportantManager.CreateAsync(
                input.Code,
                input.Name,
                input.DataGroupId, // Manager validates this and code uniqueness
                input.Order,
                input.Description,
                input.Status
            );

            await _dataImportantRepository.InsertAsync(entity, autoSave: true);
            return await MapToDtoWithDataGroupInfoAsync(entity); // Map with DataGroup info
        }

        [Authorize(CoreFWPermissions.DataImportants.Update)]
        public override async Task<DataImportantDto> UpdateAsync(Guid id, CreateUpdateDataImportantDto input)
        {
            var entity = await _dataImportantRepository.GetAsync(id); // Get entity

            // Code is immutable, check if user tried to change it via DTO
            if (!string.Equals(entity.Code, input.Code, StringComparison.OrdinalIgnoreCase))
            {
                // TODO: Localize this exception message
                throw new UserFriendlyException("Changing the DataImportant Code is not allowed.");
                // Or use a specific BusinessException/ErrorCode
            }

            // Use manager to handle update, including potential DataGroup change and related code uniqueness check
            entity = await _dataImportantManager.UpdateAsync(
                entity,
                input.Name,
                input.DataGroupId, // Manager validates if changed and checks code uniqueness in new group
                input.Order,
                input.Description,
                input.Status
            );

            await _dataImportantRepository.UpdateAsync(entity, autoSave: true);
            return await MapToDtoWithDataGroupInfoAsync(entity); // Map with DataGroup info
        }

        // Override GetAsync to include DataGroup Info
        public override async Task<DataImportantDto> GetAsync(Guid id)
        {
            // Consider using GetAsync with includeDetails if navigation property mapping is needed later
            var entity = await _dataImportantRepository.GetAsync(id);
            return await MapToDtoWithDataGroupInfoAsync(entity);
        }

        // Override GetListAsync to include DataGroup Info and handle filtering
        public override async Task<PagedResultDto<DataImportantDto>> GetListAsync(GetDataImportantsInput input)
        {
            // 1. Get count based on filters
            var totalCount = await _dataImportantRepository.GetCountAsync(
                filterText: input.Filter,
                code: null, // Use filterText
                name: null, // Use filterText
                status: input.Status,
                dataGroupId: input.DataGroupId // Filter by specific group if provided
            );

            // 2. Get list based on filters and pagination/sorting
            var entities = await _dataImportantRepository.GetListAsync(
                filterText: input.Filter,
                code: null,
                name: null,
                status: input.Status,
                dataGroupId: input.DataGroupId,
                sorting: input.Sorting ?? "Order ASC, Name ASC", // Default sort
                maxResultCount: input.MaxResultCount,
                skipCount: input.SkipCount
            );

            // 3. Fetch related DataGroup data efficiently
            var dataGroupIds = entities.Select(e => e.DataGroupId).Distinct().ToList();
            var dataGroups = new Dictionary<Guid, DataGroup>();
            if (dataGroupIds.Any())
            {
                // Use basic repository for efficient lookup
                dataGroups = (await _dataGroupRepository.GetListAsync(dg => dataGroupIds.Contains(dg.Id)))
                                .ToDictionary(dg => dg.Id);
            }

            // 4. Map to DTOs and populate DataGroup info
            var dtos = entities.Select(entity =>
            {
                var dto = ObjectMapper.Map<DataImportant, DataImportantDto>(entity);
                if (dataGroups.TryGetValue(entity.DataGroupId, out var dataGroup))
                {
                    dto.DataGroupName = dataGroup.Name;
                    dto.DataGroupCode = dataGroup.Code;
                }
                // Handle case where DataGroup might be deleted but DataImportant still exists?
                // Maybe set default names or log a warning if dataGroup is null.
                else
                {
                     dto.DataGroupName = $"<{_localizer["UnknownDataGroup"]}>"; // Or some indicator
                     dto.DataGroupCode = entity.DataGroupId.ToString();
                }
                return dto;
            }).ToList();

            return new PagedResultDto<DataImportantDto>(totalCount, dtos);
        }

        // --- Custom AppService Methods ---

        [Authorize(CoreFWPermissions.DataImportants.Default)] // Use read permission
        public async Task<ListResultDto<DataImportantLookupDto>> GetLookupByDataGroupAsync(Guid dataGroupId)
        {
            // Use the specific repository method optimized for this lookup
            var dataImportants = await _dataImportantRepository.GetListByDataGroupIdAsync(
                dataGroupId: dataGroupId,
                onlyActive: true // Only active items for lookups
            );

            var dtos = ObjectMapper.Map<List<DataImportant>, List<DataImportantLookupDto>>(dataImportants);
            return new ListResultDto<DataImportantLookupDto>(dtos);
        }

        // Optional: Implement Excel Export
        [Authorize(CoreFWPermissions.DataImportants.Export)]
        public async Task<IRemoteStreamContent> GetListAsExcelAsync(GetDataImportantsInput input)
        {
             if (_excelExportHelper == null)
            {
                 throw new UserFriendlyException("Excel export functionality is not configured.");
            }
            // 1. Get filtered list (no pagination for export)
            var entities = await _dataImportantRepository.GetListAsync(
                filterText: input.Filter,
                code: null,
                name: null,
                status: input.Status,
                dataGroupId: input.DataGroupId,
                sorting: input.Sorting ?? "Order ASC, Name ASC",
                maxResultCount: int.MaxValue, // Get all for export
                skipCount: 0
            );

            // 2. Fetch related DataGroup data efficiently
            var dataGroupIds = entities.Select(e => e.DataGroupId).Distinct().ToList();
            var dataGroups = new Dictionary<Guid, DataGroup>();
            if (dataGroupIds.Any())
            {
                dataGroups = (await _dataGroupRepository.GetListAsync(dg => dataGroupIds.Contains(dg.Id)))
                                .ToDictionary(dg => dg.Id);
            }

            // 3. Map to Excel DTOs and populate related info + localized status
            var excelDtos = entities.Select(entity =>
            {
                var dto = ObjectMapper.Map<DataImportant, DataImportantExcelDto>(entity);
                // Manually populate DataGroup info and localized StatusText
                dto.StatusText = _localizer[$"Enum:DataImportantStatus.{(int)entity.Status}"];
                if (dataGroups.TryGetValue(entity.DataGroupId, out var dataGroup))
                {
                    dto.DataGroupName = dataGroup.Name;
                    dto.DataGroupCode = dataGroup.Code;
                }
                 else
                {
                     dto.DataGroupName = $"<{_localizer["UnknownDataGroup"]}>";
                     dto.DataGroupCode = entity.DataGroupId.ToString();
                }
                return dto;
            }).ToList();

            // 4. Use helper to generate Excel file
            var fileContent = await _excelExportHelper.ExportToExcelAsync(excelDtos, "DataImportants"); // Sheet name
            return fileContent;
        }

        // --- Helper Methods ---

        /// <summary>
        /// Maps a DataImportant entity to DataImportantDto and populates DataGroup info.
        /// </summary>
        private async Task<DataImportantDto> MapToDtoWithDataGroupInfoAsync(DataImportant entity)
        {
            var dto = ObjectMapper.Map<DataImportant, DataImportantDto>(entity);
            // Fetch DataGroup info using basic repository for efficiency
            var dataGroup = await _dataGroupRepository.FindAsync(entity.DataGroupId);
            if (dataGroup != null)
            {
                dto.DataGroupName = dataGroup.Name;
                dto.DataGroupCode = dataGroup.Code;
            }
            else
            {
                 dto.DataGroupName = $"<{_localizer["UnknownDataGroup"]}>";
                 dto.DataGroupCode = entity.DataGroupId.ToString();
            }
            return dto;
        }
    }
    ```

## 3. Cập nhật `CoreFWApplicationModule.cs`

-   **Vị trí:** `src/Aqt.CoreFW.Application/CoreFWApplicationModule.cs`
-   **Hành động:** Đảm bảo rằng project `Aqt.CoreFW.Application` có tham chiếu đến `Aqt.CoreFW.Application.Contracts`. Cập nhật phương thức `ConfigureServices` để đăng ký AutoMapper profile mới.
-   **Nội dung cần thêm/cập nhật trong `ConfigureServices`:**
    ```csharp
    Configure<AbpAutoMapperOptions>(options =>
    {
        // Add all profiles in this assembly
        // options.AddMaps<CoreFWApplicationModule>();

        // Hoặc thêm từng profile cụ thể
        options.AddProfile<DataImportantApplicationAutoMapperProfile>(validate: true); // Thêm profile của DataImportant
        // options.AddProfile<DataCoreApplicationAutoMapperProfile>(validate: true); // Đảm bảo profile DataCore cũng được thêm
        // options.AddProfile<DataGroupApplicationAutoMapperProfile>(validate: true); // Đảm bảo profile DataGroup cũng được thêm
        // ... các profile khác ...
    });
    ```

## 4. Lưu ý

*   **Dependency Injection:** `DataImportantAppService` inject `IDataImportantRepository`, `DataImportantManager`, `IRepository<DataGroup, Guid>`, `IStringLocalizer`, và (tùy chọn) `IAbpExcelExportHelper`.
*   **Permissions:** Các phương thức CRUD và phương thức tùy chỉnh được bảo vệ bằng các permission đã định nghĩa trong `CoreFWPermissions.DataImportants`.
*   **Mapping:** AutoMapper được sử dụng để chuyển đổi giữa Entity và DTO. Các thông tin liên quan (DataGroupName, DataGroupCode) được load và gán trong AppService (GetListAsync, GetAsync, GetListAsExcelAsync) để tránh N+1 query.
*   **Domain Service Usage:** Logic tạo (`CreateAsync`) và cập nhật (`UpdateAsync`) phức tạp, đặc biệt là việc kiểm tra tính duy nhất của `Code` trong `DataGroupId` và xử lý thay đổi `DataGroupId`, được ủy thác cho `DataImportantManager`.
*   **Repository Usage:** AppService sử dụng `IDataImportantRepository` cho các truy vấn đặc thù của DataImportant và `IRepository<DataGroup, Guid>` để lấy thông tin DataGroup liên quan một cách hiệu quả.
*   **Error Handling:** Sử dụng `UserFriendlyException` hoặc `BusinessException` (từ Domain Service) để thông báo lỗi. Đã thêm xử lý trường hợp `DataGroup` không tìm thấy khi mapping.
*   **Excel Export:** Việc triển khai `GetListAsExcelAsync` là tùy chọn và yêu cầu cấu hình `IAbpExcelExportHelper`.
*   **Lookup Optimization:** `GetLookupByDataGroupAsync` sử dụng phương thức `GetListByDataGroupIdAsync` của repository để tối ưu.
*   **Code Immutability:** Logic trong `UpdateAsync` kiểm tra và ngăn chặn việc thay đổi `Code` sau khi tạo.
